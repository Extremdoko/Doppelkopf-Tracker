<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Extrem-Doppelkopf-Tracker V3</title>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.22.9/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f0f2f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 10px;
      box-sizing: border-box;
    }
    .container {
      background-color: #ffffff;
      border-radius: 10px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      padding: 20px;
      width: 100%;
      max-width: 1000px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .btn {
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
    }
    .btn-primary {
      background-color: #4CAF50;
      color: white;
      border: none;
    }
    .btn-primary:hover {
      background-color: #45a049;
      transform: translateY(-1px);
    }
    .btn-secondary {
      background-color: #007bff;
      color: white;
      border: none;
    }
    .btn-secondary:hover {
      background-color: #0056b3;
      transform: translateY(-1px);
    }
    .btn-danger {
      background-color: #dc3545;
      color: white;
      border: none;
    }
    .btn-danger:hover {
      background-color: #c82333;
      transform: translateY(-1px);
    }
    .btn-warning {
      background-color: #ffc107;
      color: #212529;
      border: none;
    }
    .btn-warning:hover {
      background-color: #e0a800;
      transform: translateY(-1px);
    }
    input[type="text"], input[type="number"], input[type="time"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 0.9rem;
      width: 100%;
      box-sizing: border-box;
    }
    input[type="number"].narrow {
      width: 2rem;
      text-align: center;
    }
    input[type="text"].short {
      width: 2rem;
      text-align: center;
    }
    select {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 0.9rem;
      width: 100%;
      box-sizing: border-box;
      background-color: white;
    }
    .card {
      background-color: #f9f9f9;
      border-radius: 8px;
      padding: 15px;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }
    .xlsx-card {
      padding: 8px;
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
      justify-content: center;
      align-items: center;
      transition: opacity 0.3s ease-in-out;
    }
    .modal-content {
      background-color: #fefefe;
      margin: auto;
      padding: 15px;
      border-radius: 10px;
      width: 80%;
      max-width: 400px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transform: translateY(0);
      transition: transform 0.3s ease-in-out;
    }
    .close-button {
      color: #aaa;
      float: right;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
    }
    .close-button:hover {
      color: black;
    }
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 15px;
    }
    select[multiple] {
      min-height: 80px;
    }
    .game-history-table {
      width: 100%;
      text-align: center;
      font-size: 0.85rem;
    }
    .game-history-table th, .game-history-table td {
      padding: 4px;
      border-bottom: 1px solid #e2e8f0;
      border-right: 1px solid #e2e8f0;
      line-height: 1.2;
    }
    .game-history-table th:last-child,
    .game-history-table td:last-child {
      border-right: none;
    }
    .game-history-table th {
      font-weight: 600;
      background-color: #e2e8f0;
      position: sticky;
      top: 0;
    }
    .game-history-table tbody tr:hover {
      background-color: #f0f4f8;
    }
    .points-positive {
      color: #10b981;
      font-weight: bold;
    }
    .points-negative {
      color: #ef4444;
      font-weight: bold;
    }
    .text-darkblue-bold {
      color: #1a202c;
      font-weight: bold;
    }
    .solo-indicators {
      display: flex;
      gap: 3px;
      margin-top: 2px;
    }
    .solo-indicator {
      font-size: 0.65rem;
      font-weight: 600;
    }
    .solo-indicator.completed {
      color: #10b981;
    }
    .solo-indicator.pending {
      color: #9ca3af;
    }
    .player-header-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2px;
      box-sizing: border-box;
    }
    .player-header-content.player-header-completed-solos {
      border: 2px solid #10b981;
      border-radius: 6px;
      margin: -2px;
    }
    .game-history-table th {
      border-bottom: none;
    }
    .game-history-table tbody tr:first-child td {
      border-top: 1px solid #e2e8f0;
    }
    .ranking-row {
      border-top: 2px solid #6b7280;
      margin-top: 8px;
      background-color: #e5e7eb;
      font-weight: bold;
    }
    .main-title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .main-title-symbol {
      font-size: 2rem;
      color: #1a202c;
    }
    input:invalid {
      border-color: #ef4444;
    }
    .game-type-cell, .details-cell, .winners-cell {
      white-space: normal;
      word-break: break-word;
      max-width: 100px;
    }
    .ansagen-container {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    .ansagen-column {
      flex: 1;
    }
    .sonderpunkte-container {
      flex: 2;
      display: flex;
      gap: 10px;
    }
    .sonderpunkte-column {
      flex: 1;
    }
    .divider {
      border-right: 2px solid #000;
      margin: 0 10px;
    }
    .dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-content {
      display: none;
      position: absolute;
      background-color: #fff;
      min-width: 160px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1;
      border-radius: 6px;
      padding: 8px;
    }
    .dropdown-content.show {
      display: block;
    }
    .dropdown-content label {
      display: flex;
      align-items: center;
      padding: 4px;
    }
    .dropdown-content input {
      margin-right: 8px;
    }
    .tooltip {
      position: relative;
    }
    .tooltip:hover::after {
      content: attr(data-tip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/javascript">
    var gk_isXlsx = false;
    var gk_xlsxFileLookup = {};
    var gk_fileData = {};
    function filledCell(cell) {
      return cell !== '' && cell != null;
    }
    function loadFileData(filename) {
      if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
        try {
          var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
          var firstSheetName = workbook.SheetNames[0];
          var worksheet = workbook.Sheets[firstSheetName];
          var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
          var filteredData = jsonData.filter(row => row.some(filledCell));
          var headerRowIndex = filteredData.findIndex((row, index) =>
            row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
          );
          if (headerRowIndex === -1 || headerRowIndex > 25) {
            headerRowIndex = 0;
          }
          var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex));
          csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
          return csv;
        } catch (e) {
          console.error(e);
          return "";
        }
      }
      return gk_fileData[filename] || "";
    }
  </script>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const initialPlayerSoloStatus = {
      knochenloser: false,
      bilder: false,
      farbe: false,
    };

    const defaultPlayers = [
      { name: 'Krister', initials: 'K' },
      { name: 'Christoph', initials: 'C' },
      { name: 'Sine', initials: 'S' },
      { name: 'Tommy', initials: 'T' }
    ];

    const PlayerManagement = ({ players, setPlayers, newPlayerName, setNewPlayerName, newPlayerInitials, setNewPlayerInitials, addPlayer, removePlayer, movePlayer, currentDealer, setShowDealerSelectionModal }) => {
      return (
        <div className="card">
          <h2 className="text-lg font-semibold text-gray-700 mb-2 text-center">Spieler verwalten</h2>
          <div className="flex flex-col sm:flex-row gap-2 mb-3 justify-center">
            <input
              type="text"
              placeholder="Name"
              value={newPlayerName}
              onChange={e => setNewPlayerName(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && addPlayer(newPlayerName, newPlayerInitials)}
              className="border p-2 rounded"
              aria-label="Neuer Spielername"
            />
            <input
              type="text"
              placeholder="Kürzel"
              value={newPlayerInitials}
              onChange={e => setNewPlayerInitials(e.target.value.toUpperCase())}
              maxLength="1"
              className="border p-2 rounded short"
              aria-label="Spieler-Kürzel"
            />
            <button className="btn btn-primary" onClick={() => addPlayer(newPlayerName, newPlayerInitials)} aria-label="Spieler hinzufügen">
              Hinzufügen
            </button>
          </div>
          <div className="flex flex-wrap gap-2 justify-center mb-3">
            {players.map((player, index) => (
              <span key={player.name} className="bg-blue-200 text-blue-800 px-2 py-1 rounded-full flex items-center gap-2 font-bold">
                {player.name} ({player.initials})
                <div className="flex flex-col ml-2">
                  <button
                    className="text-blue-600 hover:text-blue-900 text-xs leading-none"
                    onClick={() => movePlayer(player.name, -1)}
                    disabled={index === 0}
                    aria-label={`Spieler ${player.name} nach oben verschieben`}
                  >
                    ▲
                  </button>
                  <button
                    className="text-blue-600 hover:text-blue-900 text-xs leading-none"
                    onClick={() => movePlayer(player.name, 1)}
                    disabled={index === players.length - 1}
                    aria-label={`Spieler ${player.name} nach unten verschieben`}
                  >
                    ▼
                  </button>
                </div>
                <button
                  className="text-blue-600 hover:text-blue-900 font-bold"
                  onClick={() => removePlayer(player.name)}
                  aria-label={`Spieler ${player.name} entfernen`}
                >
                  x
                </button>
              </span>
            ))}
          </div>
          <button
            className="btn btn-secondary w-full"
            onClick={() => setShowDealerSelectionModal(true)}
            aria-label="Erster Geber am Abend festlegen"
          >
            Erster Geber am Abend festlegen
          </button>
          {currentDealer && (
            <p className="text-center text-gray-700 mt-2">
              Aktueller Geber: <span className="font-bold">{players.find(p => p.name === currentDealer)?.initials || currentDealer}</span>
            </p>
          )}
        </div>
      );
    };

    const PotDisplay = ({ pot }) => {
      return (
        <div className="card text-center bg-green-100 p-4 rounded-lg shadow-md">
          <h2 className="text-xl font-semibold text-gray-700">Aktueller Pot</h2>
          <p className={`text-4xl font-bold ${pot <= 0 ? 'text-red-700' : 'text-green-700'}`}>{pot}</p>
        </div>
      );
    };

    const GameInputForm = ({ gameType, setGameType, winningPlayers, setWinningPlayers, points, setPoints, ansagen, setAnsagen, ansagenPlayers, setAnsagenPlayers, showAnsagenDropdown, setShowAnsagenDropdown, sonderpunkte, setSonderpunkte, noStichMade, setNoStichMade, vorgefuehrtePlayer, setVorgefuehrtePlayer, addGame, players, editingGameIndex }) => {
      const dropdownRef = useRef(null);

      const toggleAnsagenDropdown = (key) => {
        setShowAnsagenDropdown(showAnsagenDropdown === key ? null : key);
      };

      const handleAnsagenPlayerChange = (key, playerName) => {
        setAnsagenPlayers(prev => ({
          ...prev,
          [key]: prev[key].includes(playerName)
            ? prev[key].filter(p => p !== playerName)
            : [...prev[key], playerName]
        }));
      };

      return (
        <div className="card">
          <h2 className="text-lg font-semibold text-gray-700 mb-2 text-center">Spieltyp / Punkte / Ansagen / Sonderpunkte</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3">
            <div>
              <label className="block text-gray-700 text-sm font-bold mb-1">Spieltyp:</label>
              <select
                value={gameType}
                onChange={e => setGameType(e.target.value)}
                className="w-full"
                aria-label="Spieltyp auswählen"
              >
                <option value="normal">Normalspiel</option>
                <optgroup label="Pflichtsolo">
                  <option value="pflichtsolo_knochenloser">Knochenloser</option>
                  <option value="pflichtsolo_bilder">Bilder</option>
                  <option value="pflichtsolo_farbe">Farbe</option>
                </optgroup>
                <optgroup label="Lüstling">
                  <option value="lustling_knochenloser">Knochenloser</option>
                  <option value="lustling_bilder">Bilder</option>
                  <option value="lustling_farbe">Farbe</option>
                </optgroup>
                <option value="schlanker_martin">Schlanker Martin</option>
                <option value="stilles_solo">Stilles Solo</option>
                <option value="rote_luise">Rote Luise</option>
              </select>
            </div>
            <div>
              <label className="block text-gray-700 text-sm font-bold mb-1">Gewinner:</label>
              <select
                multiple
                value={winningPlayers}
                onChange={e => setWinningPlayers(Array.from(e.target.selectedOptions).map(o => o.value))}
                className="w-full"
                aria-label="Gewinner auswählen"
              >
                {players.map(player => (
                  <option key={player.name} value={player.name} className="font-bold">{player.name} ({player.initials})</option>
                ))}
              </select>
            </div>
            <div className="col-span-full">
              <label className="block text-gray-700 text-sm font-bold mb-1">Punkte der Gewinner:</label>
              <div className="flex justify-center">
                <input
                  type="number"
                  value={points}
                  onChange={e => setPoints(Number(e.target.value))}
                  min="0"
                  max="240"
                  className="border p-2 rounded w-24"
                  aria-label="Punkte der Gewinner"
                />
              </div>
            </div>
            <div className="col-span-full">
              <label className="block text-gray-700 text-sm font-bold mb-1">Vorgeführter Spieler (optional):</label>
              <select
                value={vorgefuehrtePlayer || ''}
                onChange={e => setVorgefuehrtePlayer(e.target.value === '' ? null : e.target.value)}
                className="w-full"
                aria-label="Vorgeführter Spieler auswählen"
              >
                <option value="">Kein vorgeführter Spieler</option>
                {players.map(player => (
                  <option key={player.name} value={player.name}>{player.name} ({player.initials})</option>
                ))}
              </select>
            </div>
          </div>
          {gameType === 'schlanker_martin' && (
            <div className="mb-3">
              <label className="inline-flex items-center">
                <input
                  type="checkbox"
                  checked={noStichMade}
                  onChange={() => setNoStichMade(!noStichMade)}
                  className="form-checkbox h-4 w-4 text-red-600 rounded"
                  aria-label="Kein Stich gemacht bei Schlanker Martin aktivieren"
                />
                <span className="ml-2 text-gray-700 text-sm">Kein Stich gemacht (Schlanker Martin)</span>
              </label>
            </div>
          )}
          <div className="ansagen-container mb-3">
            <div className="ansagen-column">
              <label className="block text-gray-700 text-sm font-bold mb-1">Ansagen:</label>
              <div className="grid grid-cols-1 gap-1">
                {[
                  { key: 'GegenDieAlten', label: 'Gegen die Alten' },
                  { key: 'Re', label: 'Re' },
                  { key: 'Kontra', label: 'Kontra' },
                  { key: 'ReKontra', label: 'Re/Kontra (Genscher)' },
                ].map(({ key, label }) => (
                  <div key={key} className="dropdown" ref={showAnsagenDropdown === key ? dropdownRef : null}>
                    <label className={`inline-flex items-center ${gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p.name)).length === 1 ? 'opacity-50' : ''}`}>
                      <input
                        type="checkbox"
                        checked={ansagen[key]}
                        onChange={() => {
                          setAnsagen(prev => ({ ...prev, [key]: !prev[key] }));
                          toggleAnsagenDropdown(key);
                        }}
                        disabled={gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p.name)).length === 1}
                        className="form-checkbox h-4 w-4 text-blue-600 rounded"
                        aria-label={`Ansage ${label} aktivieren`}
                        onKeyDown={e => e.key === 'Enter' && setAnsagen(prev => ({ ...prev, [key]: !prev[key] }))}
                      />
                      <span className="ml-2 text-gray-700 text-sm">{label}</span>
                    </label>
                    {showAnsagenDropdown === key && (
                      <div className="dropdown-content show">
                        {players.map(player => (
                          <label key={player.name} className="inline-flex items-center">
                            <input
                              type="checkbox"
                              checked={ansagenPlayers[key].includes(player.name)}
                              onChange={() => handleAnsagenPlayerChange(key, player.name)}
                              className="form-checkbox h-4 w-4 text-blue-600 rounded"
                              aria-label={`Spieler ${player.name} für Ansage ${label} auswählen`}
                            />
                            <span className="ml-2 text-gray-700 text-sm">{player.name} ({player.initials})</span>
                          </label>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
            <div className="ansagen-column">
              <label className="block text-gray-700 text-sm font-bold mb-1">Keine X:</label>
              <div className="grid grid-cols-1 gap-1">
                {[
                  { key: 'Keine90', label: 'Keine 90' },
                  { key: 'Keine60', label: 'Keine 60' },
                  { key: 'Keine30', label: 'Keine 30' },
                  { key: 'Keine0', label: 'Keine 0' },
                ].map(({ key, label }) => (
                  <div key={key} className="dropdown" ref={showAnsagenDropdown === key ? dropdownRef : null}>
                    <label className={`inline-flex items-center ${gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p.name)).length === 1 ? 'opacity-50' : ''}`}>
                      <input
                        type="checkbox"
                        checked={ansagen[key]}
                        onChange={() => {
                          setAnsagen(prev => ({ ...prev, [key]: !prev[key] }));
                          toggleAnsagenDropdown(key);
                        }}
                        disabled={gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p.name)).length === 1}
                        className="form-checkbox h-4 w-4 text-blue-600 rounded"
                        aria-label={`Ansage ${label} aktivieren`}
                        onKeyDown={e => e.key === 'Enter' && setAnsagen(prev => ({ ...prev, [key]: !prev[key] }))}
                      />
                      <span className="ml-2 text-gray-700 text-sm">{label}</span>
                    </label>
                    {showAnsagenDropdown === key && (
                      <div className="dropdown-content show">
                        {players.map(player => (
                          <label key={player.name} className="inline-flex items-center">
                            <input
                              type="checkbox"
                              checked={ansagenPlayers[key].includes(player.name)}
                              onChange={() => handleAnsagenPlayerChange(key, player.name)}
                              className="form-checkbox h-4 w-4 text-blue-600 rounded"
                              aria-label={`Spieler ${player.name} für Ansage ${label} auswählen`}
                            />
                            <span className="ml-2 text-gray-700 text-sm">{player.name} ({player.initials})</span>
                          </label>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            </div>
            <div className="divider"></div>
            <div className="sonderpunkte-container">
              <div className="sonderpunkte-column">
                <label className="block text-gray-700 text-sm font-bold mb-1">Gewinner:</label>
                {[
                  { key: 'FuchsGefangenWinner', label: 'Fuchs gefangen' },
                  { key: 'DoppelkopfWinner', label: 'Doppelkopf' },
                  { key: 'KarlchenMuellerWinner', label: 'Karlchen Müller' },
                  { key: 'FuchsMachtLetztenStichWinner', label: 'Fuchs letzter Stich' },
                ].map(({ key, label }) => (
                  <label key={key} className="flex items-center gap-2 mb-1">
                    <input
                      type="number"
                      value={sonderpunkte[key]}
                      onChange={e => setSonderpunkte(prev => ({ ...prev, [key]: Math.min(9, Math.max(0, Number(e.target.value))) }))}
                      min="0"
                      max="9"
                      maxLength="1"
                      className="border p-1 rounded narrow text-center"
                      aria-label={label}
                    />
                    <span className="text-gray-700 text-sm">{label}</span>
                  </label>
                ))}
              </div>
              <div className="sonderpunkte-column">
                <label className="block text-gray-700 text-sm font-bold mb-1">Verlierer:</label>
                {[
                  { key: 'FuchsGefangenLoser', label: 'Fuchs gefangen' },
                  { key: 'DoppelkopfLoser', label: 'Doppelkopf' },
                  { key: 'KarlchenMuellerLoser', label: 'Karlchen Müller' },
                  { key: 'FuchsMachtLetztenStichLoser', label: 'Fuchs letzter Stich' },
                ].map(({ key, label }) => (
                  <label key={key} className="flex items-center gap-2 mb-1">
                    <input
                      type="number"
                      value={sonderpunkte[key]}
                      onChange={e => setSonderpunkte(prev => ({ ...prev, [key]: Math.min(9, Math.max(0, Number(e.target.value))) }))}
                      min="0"
                      max="9"
                      maxLength="1"
                      className="border p-1 rounded narrow text-center"
                      aria-label={label}
                    />
                    <span className="text-gray-700 text-sm">{label}</span>
                  </label>
                ))}
              </div>
            </div>
          </div>
          <div className="mt-3">
            <div className="tooltip" data-tip="Schlanker Martin Sonderpunkt verdoppelt die Punkte, wenn kein Stich gemacht wurde">
              <label className={`inline-flex items-center ${gameType !== 'schlanker_martin' ? 'opacity-50' : ''}`}>
                <input
                  type="checkbox"
                  checked={sonderpunkte.SchlankerMartinSonderpunkt}
                  onChange={() => setSonderpunkte(prev => ({ ...prev, SchlankerMartinSonderpunkt: !prev.SchlankerMartinSonderpunkt }))}
                  disabled={gameType !== 'schlanker_martin'}
                  className="form-checkbox h-4 w-4 text-purple-600 rounded"
                  aria-label="Schlanker Martin Sonderpunkt aktivieren"
                />
                <span className="ml-2 text-gray-700 text-sm">Schlanker Martin Sonderpunkt</span>
              </label>
            </div>
          </div>
          <button className="btn btn-secondary w-full text-base mt-3" onClick={addGame} aria-label="Spiel protokollieren">
            {editingGameIndex !== null ? 'Änderungen speichern' : 'Protokollieren'}
          </button>
        </div>
      );
    };

    const GameHistoryTable = ({ gameHistory, players, playerSoloStatus, deleteGame, editGame }) => {
      const getGameTypeDisplay = (game) => {
        const isSoloGame = game.gameType.includes('solo') || game.gameType === 'schlanker_martin' || game.gameType === 'rote_luise';
        if (isSoloGame) {
          const isWon = game.winner.length === 1;
          if (game.gameType === 'schlanker_martin') {
            return `Schlanker Martin (${game.points})${isWon ? ', gewonnen' : ', verloren'}`;
          }
          if (game.gameType === 'rote_luise') {
            return `Rote Luise (${game.points})${isWon ? ', gewonnen' : ', verloren'}`;
          }
          if (game.gameType === 'stilles_solo') {
            return `Stilles Solo (${game.points})${isWon ? ', gewonnen' : ', verloren'}`;
          }
          const [type, category] = game.gameType.split('_');
          const prefix = type === 'pflichtsolo' ? '(P)' : '(L)';
          const categoryDisplay = category.charAt(0).toUpperCase() + category.slice(1);
          return `${categoryDisplay} ${prefix} (${game.points})${isWon ? ', gewonnen' : ', verloren'}`;
        }
        return `${game.gameType.charAt(0).toUpperCase() + game.gameType.slice(1)} (${game.points})`;
      };

      const getDetailsDisplay = (game) => {
        const keineX = game.ansagen.find(a => ['Keine90', 'Keine60', 'Keine30', 'Keine0'].includes(a.type));
        const ansagenDisplay = game.ansagen
          .filter(a => !['Keine90', 'Keine60', 'Keine30', 'Keine0'].includes(a.type))
          .map(a => `${a.type}${a.players.length > 0 ? ` (${a.players.map(p => players.find(pl => pl.name === p)?.initials || p).join(', ')})` : ''}`);
        const sonderpunkteDisplay = game.sonderpunkte.map(sp => {
          const [key, value] = sp.split(':');
          const spLabels = {
            DoppelkopfWinner: `Doppelkopf (G): ${value}`,
            DoppelkopfLoser: `Doppelkopf (V): ${value}`,
            KarlchenMuellerWinner: `Karlchen Müller (G): ${value}`,
            KarlchenMuellerLoser: `Karlchen Müller (V): ${value}`,
            FuchsGefangenWinner: `Fuchs gefangen (G): ${value}`,
            FuchsGefangenLoser: `Fuchs gefangen (V): ${value}`,
            FuchsMachtLetztenStichWinner: `Fuchs letzter Stich (G): ${value}`,
            FuchsMachtLetztenStichLoser: `Fuchs letzter Stich (V): ${value}`,
            SchlankerMartinSonderpunkt: 'Schlanker Martin Sonderpunkt',
          };
          return spLabels[key] || `${key}: ${value}`;
        });
        const details = [];
        if (keineX) details.push(`${keineX.type}${keineX.players.length > 0 ? ` (${keineX.players.map(p => players.find(pl => pl.name === p)?.initials || p).join(', ')})` : ''}`);
        details.push(...ansagenDisplay);
        details.push(...sonderpunkteDisplay);
        return details.join('; ') || '-';
      };

      const totalScores = players.reduce((acc, player) => {
        const score = gameHistory.reduce((sum, game) => sum + (game.playerScores[player.name] || 0), 0) - 30;
        return { ...acc, [player.name]: score };
      }, {});

      const ranking = players
        .map(player => ({ name: player.name, initials: player.initials, score: totalScores[player.name] }))
        .sort((a, b) => b.score - a.score)
        .map((player, index) => ({ ...player, rank: index + 1 }));

      return (
        <div className="card">
          <h2 className="text-lg font-semibold text-gray-700 mb-2">Spielverlauf</h2>
          <div className="overflow-x-auto">
            <table className="game-history-table w-full text-left table-auto">
              <thead>
                <tr className="bg-gray-200 text-gray-700">
                  <th className="p-2 whitespace-nowrap rounded-tl-lg border-r border-gray-300">Geber</th>
                  <th className="p-2 game-type-cell border-r border-gray-300">Spiel</th>
                  <th className="p-2 winners-cell border-r border-gray-300">Gewinner</th>
                  <th className="p-2 details-cell border-r border-gray-300">Details</th>
                  {players.map((player, index) => (
                    <th key={player.name} className={`p-2 whitespace-nowrap text-center ${index < players.length - 1 ? 'border-r border-gray-300' : ''}`}>
                      <div className={`player-header-content ${Object.values(playerSoloStatus[player.name] || {}).every(status => status) ? 'player-header-completed-solos' : ''}`}>
                        {player.initials}
                        <div className="solo-indicators">
                          <span className={`solo-indicator ${playerSoloStatus[player.name]?.knochenloser ? 'completed' : 'pending'}`}>K</span>
                          <span className={`solo-indicator ${playerSoloStatus[player.name]?.bilder ? 'completed' : 'pending'}`}>B</span>
                          <span className={`solo-indicator ${playerSoloStatus[player.name]?.farbe ? 'completed' : 'pending'}`}>F</span>
                        </div>
                      </div>
                    </th>
                  ))}
                  <th className="p-2">Aktionen</th>
                </tr>
              </thead>
              <tbody>
                {gameHistory.map((game, index) => (
                  <tr key={index}>
                    <td className="p-2 border-r border-gray-300">{players.find(p => p.name === game.dealer)?.initials || game.dealer}</td>
                    <td className="p-2 game-type-cell border-r border-gray-300">{getGameTypeDisplay(game)}</td>
                    <td className="p-2 winners-cell border-r border-gray-300">{game.winner.map(p => players.find(pl => pl.name === p)?.initials || p).join(', ')}</td>
                    <td className="p-2 details-cell border-r border-gray-300">{getDetailsDisplay(game)}</td>
                    {players.map(player => (
                      <td key={player.name} className={`p-2 text-center border-r border-gray-300 ${game.playerScores[player.name] > 0 ? 'points-positive' : game.playerScores[player.name] < 0 ? 'points-negative' : ''}`}>
                        {game.playerScores[player.name] || 0}
                      </td>
                    ))}
                    <td className="p-2">
                      <button className="btn btn-warning mr-2" onClick={() => editGame(index)} aria-label={`Spiel ${index + 1} bearbeiten`}>Bearbeiten</button>
                      <button className="btn btn-danger" onClick={() => deleteGame(index)} aria-label={`Spiel ${index + 1} löschen`}>Löschen</button>
                    </td>
                  </tr>
                ))}
                <tr className="ranking-row">
                  <td className="p-2 border-r border-gray-300 font-bold">Stand</td>
                  <td className="p-2 border-r border-gray-300"></td>
                  <td className="p-2 border-r border-gray-300"></td>
                  <td className="p-2 border-r border-gray-300"></td>
                  {players.map(player => (
                    <td key={player.name} className={`p-2 text-center border-r border-gray-300 ${totalScores[player.name] > 0 ? 'points-positive' : totalScores[player.name] < 0 ? 'points-negative' : ''}`}>
                      {totalScores[player.name]}
                    </td>
                  ))}
                  <td className="p-2"></td>
                </tr>
                <tr className="ranking-row">
                  <td className="p-2 border-r border-gray-300 font-bold">Ranking</td>
                  <td className="p-2 border-r border-gray-300"></td>
                  <td className="p-2 border-r border-gray-300"></td>
                  <td className="p-2 border-r border-gray-300"></td>
                  {players.map(player => {
                    const playerRanking = ranking.find(r => r.name === player.name);
                    return (
                      <td key={player.name} className="p-2 text-center border-r border-gray-300">
                        {playerRanking ? playerRanking.rank + '.' : '-'}
                      </td>
                    );
                  })}
                  <td className="p-2"></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      );
    };

    const Modal = ({ showModal, setShowModal, modalMessage, modalCallback }) => {
      return (
        <div className="modal" style={{ display: showModal ? 'flex' : 'none' }}>
          <div className="modal-content">
            <span className="close-button" onClick={() => setShowModal(false)}>×</span>
            <p>{modalMessage}</p>
            {modalCallback && (
              <div className="modal-buttons">
                <button className="btn btn-primary" onClick={() => { modalCallback(); setShowModal(false); }}>Ja</button>
                <button className="btn btn-secondary" onClick={() => setShowModal(false)}>Nein</button>
              </div>
            )}
          </div>
        </div>
      );
    };

    const DealerSelectionModal = ({ showDealerSelectionModal, setShowDealerSelectionModal, players, setCurrentDealer }) => {
      return (
        <div className="modal" style={{ display: showDealerSelectionModal ? 'flex' : 'none' }}>
          <div className="modal-content">
            <span className="close-button" onClick={() => setShowDealerSelectionModal(false)}>×</span>
            <h2 className="text-lg font-semibold text-gray-700 mb-2">Erster Geber am Abend</h2>
            <select
              onChange={e => { setCurrentDealer(e.target.value); setShowDealerSelectionModal(false); }}
              className="w-full"
              aria-label="Erster Geber auswählen"
            >
              <option value="">Geber auswählen</option>
              {players.map(player => (
                <option key={player.name} value={player.name}>{player.name} ({player.initials})</option>
              ))}
            </select>
          </div>
        </div>
      );
    };

    const ReplacePlayerModal = ({ showReplaceModal, setShowReplaceModal, players, playerToReplace, setPlayerToReplace, newPlayerName, setNewPlayerName, newPlayerInitials, setNewPlayerInitials, replacePlayer }) => {
      return (
        <div className="modal" style={{ display: showReplaceModal ? 'flex' : 'none' }}>
          <div className="modal-content">
            <span className="close-button" onClick={() => setShowReplaceModal(false)}>×</span>
            <h2 className="text-lg font-semibold text-gray-700 mb-2">Spieler ersetzen</h2>
            <label className="block text-gray-700 text-sm font-bold mb-1">Zu ersetzender Spieler:</label>
            <select
              value={playerToReplace}
              onChange={e => setPlayerToReplace(e.target.value)}
              className="w-full mb-3"
              aria-label="Spieler zum Ersetzen auswählen"
            >
              <option value="">Spieler auswählen</option>
              {players.map(player => (
                <option key={player.name} value={player.name}>{player.name} ({player.initials})</option>
              ))}
            </select>
            <label className="block text-gray-700 text-sm font-bold mb-1">Neuer Name:</label>
            <input
              type="text"
              value={newPlayerName}
              onChange={e => setNewPlayerName(e.target.value)}
              className="border p-2 rounded w-full mb-3"
              aria-label="Neuer Spielername"
            />
            <label className="block text-gray-700 text-sm font-bold mb-1">Neues Kürzel:</label>
            <input
              type="text"
              value={newPlayerInitials}
              onChange={e => setNewPlayerInitials(e.target.value.toUpperCase())}
              maxLength="1"
              className="border p-2 rounded w-full mb-3"
              aria-label="Neues Spieler-Kürzel"
            />
            <div className="modal-buttons">
              <button className="btn btn-primary" onClick={replacePlayer}>Ersetzen</button>
              <button className="btn btn-secondary" onClick={() => setShowReplaceModal(false)}>Abbrechen</button>
            </div>
          </div>
        </div>
      );
    };

    const App = () => {
      const [players, setPlayers] = useState(defaultPlayers);
      const [pot, setPot] = useState(120);
      const [gameHistory, setGameHistory] = useState([]);
      const [playerSoloStatus, setPlayerSoloStatus] = useState({});
      const [gameType, setGameType] = useState('normal');
      const [winningPlayers, setWinningPlayers] = useState([]);
      const [points, setPoints] = useState(120);
      const [ansagen, setAnsagen] = useState({
        GegenDieAlten: false,
        Re: false,
        Kontra: false,
        ReKontra: false,
        Keine90: false,
        Keine60: false,
        Keine30: false,
        Keine0: false,
      });
      const [ansagenPlayers, setAnsagenPlayers] = useState({
        GegenDieAlten: [], Re: [], Kontra: [], ReKontra: [],
        Keine90: [], Keine60: [], Keine30: [], Keine0: []
      });
      const [showAnsagenDropdown, setShowAnsagenDropdown] = useState(null);
      const [sonderpunkte, setSonderpunkte] = useState({
        DoppelkopfWinner: 0, DoppelkopfLoser: 0, KarlchenMuellerWinner: 0, KarlchenMuellerLoser: 0,
        FuchsGefangenWinner: 0, FuchsGefangenLoser: 0, FuchsMachtLetztenStichWinner: 0, FuchsMachtLetztenStichLoser: 0,
        SchlankerMartinSonderpunkt: false,
      });
      const [noStichMade, setNoStichMade] = useState(false);
      const [timeBomb, setTimeBomb] = useState('');
      const [modalMessage, setModalMessage] = useState('');
      const [showModal, setShowModal] = useState(false);
      const [modalCallback, setModalCallback] = useState(null);
      const [showReplaceModal, setShowReplaceModal] = useState(false);
      const [newPlayerName, setNewPlayerName] = useState('');
      const [newPlayerInitials, setNewPlayerInitials] = useState('');
      const [playerToReplace, setPlayerToReplace] = useState('');
      const [currentDealer, setCurrentDealer] = useState(null);
      const [vorgefuehrtePlayer, setVorgefuehrtePlayer] = useState(null);
      const [showDealerSelectionModal, setShowDealerSelectionModal] = useState(false);
      const [historyStates, setHistoryStates] = useState([]);
      const [historyPointer, setHistoryPointer] = useState(-1);
      const [editingGameIndex, setEditingGameIndex] = useState(null);
      const [uploadedData, setUploadedData] = useState('');

      const dropdownRef = useRef(null);

      useEffect(() => {
        setPlayers(defaultPlayers);
        defaultPlayers.forEach(p => setPlayerSoloStatus(prev => ({ ...prev, [p.name]: { ...initialPlayerSoloStatus } })));
        saveStateToHistory({
          players: defaultPlayers,
          pot: 120,
          gameHistory: [],
          playerSoloStatus: defaultPlayers.reduce((acc, p) => ({ ...acc, [p.name]: { ...initialPlayerSoloStatus } }), {}),
          currentDealer: null
        });
      }, []);

      useEffect(() => {
        const handleClickOutside = (event) => {
          if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
            setShowAnsagenDropdown(null);
          }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
      }, []);

      useEffect(() => {
        recalculateSoloStatus();
      }, [gameHistory, players]);

      useEffect(() => {
        if (!timeBomb) return;
        const [hours, minutes] = timeBomb.split(':');
        const timeBombDate = new Date();
        timeBombDate.setHours(hours, minutes, 0, 0);
        const interval = setInterval(() => {
          if (new Date() >= timeBombDate) {
            setModalMessage('Zeitzünder erreicht! Nur Pflichtsoli können gespielt werden.');
            setShowModal(true);
            setGameType('pflichtsolo_knochenloser');
          }
        }, 60000);
        return () => clearInterval(interval);
      }, [timeBomb]);

      useEffect(() => {
        const losingPlayers = players.filter(p => !winningPlayers.includes(p.name)).map(p => p.name);
        if (gameType === 'rote_luise' && losingPlayers.length === 1) {
          setAnsagen(prev => ({
            ...prev,
            Keine90: points <= 90,
            Keine60: points <= 60,
            Keine30: points <= 30,
            Keine0: points === 0,
          }));
        } else if (gameType !== 'rote_luise' && gameType !== 'schlanker_martin') {
          setAnsagen(prev => ({
            ...prev,
            Keine90: false,
            Keine60: false,
            Keine30: false,
            Keine0: false,
          }));
        }
      }, [points, winningPlayers, gameType, players]);

      const applyState = (state) => {
        setPlayers(state.players);
        setPot(state.pot);
        setGameHistory(state.gameHistory);
        setPlayerSoloStatus(state.playerSoloStatus);
        setCurrentDealer(state.currentDealer || null);
      };

      const saveStateToHistory = (currentState) => {
        const newHistory = historyStates.slice(0, historyPointer + 1);
        setHistoryStates([...newHistory, currentState]);
        setHistoryPointer(newHistory.length);
      };

      const calculatePotChange = (gameType, winningPlayers, ansagen, sonderpunkte) => {
        let basePoints = 0;
        if (gameType !== 'normal') return 0;

        if (points >= 121 && points <= 150) basePoints = 1;
        else if (points >= 151 && points <= 180) basePoints = 2;
        else if (points >= 181 && points <= 210) basePoints = 3;
        else if (points >= 211 && points <= 240) basePoints = 4;

        let ansagenPoints = 0;
        if (ansagen.GegenDieAlten) ansagenPoints += 1;
        if (ansagen.Re) ansagenPoints += 2;
        if (ansagen.Kontra) ansagenPoints += 2;
        if (ansagen.ReKontra) ansagenPoints += 2;

        let keineXPoints = 0;
        if (ansagen.Keine0) keineXPoints = 4;
        else if (ansagen.Keine30) keineXPoints = 3;
        else if (ansagen.Keine60) keineXPoints = 2;
        else if (ansagen.Keine90) keineXPoints = 1;
        ansagenPoints += keineXPoints;

        let winnerBonus = sonderpunkte.DoppelkopfWinner + sonderpunkte.KarlchenMuellerWinner +
                         sonderpunkte.FuchsGefangenWinner + sonderpunkte.FuchsMachtLetztenStichWinner;
        let loserPenalty = sonderpunkte.DoppelkopfLoser + sonderpunkte.KarlchenMuellerLoser +
                          sonderpunkte.FuchsGefangenLoser + sonderpunkte.FuchsMachtLetztenStichLoser;

        return (basePoints + ansagenPoints + winnerBonus - loserPenalty) * winningPlayers.length;
      };

      const calculateIndividualGameScores = useCallback((gameType, winningPlayers, losingPlayers, ansagen, sonderpunkte, noStichMade, points) => {
        const playerScores = players.reduce((acc, p) => ({ ...acc, [p.name]: 0 }), {});
        const isSoloGame = gameType.includes('solo') || gameType === 'schlanker_martin' || gameType === 'rote_luise' || gameType.startsWith('pflichtsolo') || gameType.startsWith('lustling');

        let basePoints = 0;
        let ansagenPoints = 0;
        let winnerBonus = 0;
        let loserPenalty = 0;

        if (gameType === 'normal') {
          if (points >= 121 && points <= 150) basePoints = 1;
          else if (points >= 151 && points <= 180) basePoints = 2;
          else if (points >= 181 && points <= 210) basePoints = 3;
          else if (points >= 211 && points <= 240) basePoints = 4;
        } else {
          basePoints = 1;
          if (gameType === 'rote_luise') {
            basePoints = 0;
          }
        }

        if (ansagen.GegenDieAlten) ansagenPoints += 1;
        if (ansagen.Re) ansagenPoints += 2;
        if (ansagen.Kontra) ansagenPoints += 2;
        if (ansagen.ReKontra) ansagenPoints += 2;

        let keineXPoints = 0;
        if (ansagen.Keine0) keineXPoints = 4;
        else if (ansagen.Keine30) keineXPoints = 3;
        else if (ansagen.Keine60) keineXPoints = 2;
        else if (ansagen.Keine90) keineXPoints = 1;
        ansagenPoints += keineXPoints;

        winnerBonus += sonderpunkte.DoppelkopfWinner;
        winnerBonus += sonderpunkte.KarlchenMuellerWinner;
        winnerBonus += sonderpunkte.FuchsGefangenWinner;
        winnerBonus += sonderpunkte.FuchsMachtLetztenStichWinner;

        loserPenalty += sonderpunkte.DoppelkopfLoser;
        loserPenalty += sonderpunkte.KarlchenMuellerLoser;
        loserPenalty += sonderpunkte.FuchsGefangenLoser;
        loserPenalty += sonderpunkte.FuchsMachtLetztenStichLoser;

        if (gameType === 'schlanker_martin' && noStichMade) {
          const smPointsPerOpponent = sonderpunkte.SchlankerMartinSonderpunkt ? 2 : 1;
          playerScores[winningPlayers[0]] = smPointsPerOpponent * 3;
          losingPlayers.forEach(p => playerScores[p] = -smPointsPerOpponent);
          return playerScores;
        }

        const adjustedBaseScore = basePoints + ansagenPoints + winnerBonus - loserPenalty;

        if (gameType === 'normal') {
          winningPlayers.forEach(p => playerScores[p] = adjustedBaseScore);
          losingPlayers.forEach(p => playerScores[p] = 0);
        } else if (isSoloGame) {
          if (winningPlayers.length === 1) {
            playerScores[winningPlayers[0]] = adjustedBaseScore * 3;
            losingPlayers.forEach(p => playerScores[p] = -adjustedBaseScore);
          } else if (losingPlayers.length === 1) {
            playerScores[losingPlayers[0]] = -adjustedBaseScore * 3;
            winningPlayers.forEach(p => playerScores[p] = adjustedBaseScore);
          }
        }
        return playerScores;
      }, [players]);

      const recalculateSoloStatus = () => {
        const newStatus = players.reduce((acc, p) => ({ ...acc, [p.name]: { ...initialPlayerSoloStatus } }), {});
        gameHistory.forEach(game => {
          if (game.gameType.startsWith('pflichtsolo')) {
            const isWonSolo = game.winner.length === 1 && game.loser.length === 3;
            const isLostSolo = game.loser.length === 1 && game.winner.length === 3;
            const soloist = isWonSolo ? game.winner[0] : isLostSolo ? game.loser[0] : null;
            if (soloist && newStatus[soloist]) {
              const soloCategory = game.gameType.split('_')[1];
              if (newStatus[soloist][soloCategory] !== undefined) {
                newStatus[soloist][soloCategory] = true;
              }
            }
          }
        });
        setPlayerSoloStatus(newStatus);
      };

      const movePlayer = (playerName, direction) => {
        const currentIndex = players.findIndex(p => p.name === playerName);
        if (currentIndex === -1) return;

        const newIndex = currentIndex + direction;
        if (newIndex < 0 || newIndex >= players.length) return;

        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus, currentDealer });

        const newPlayers = [...players];
        const [removedPlayer] = newPlayers.splice(currentIndex, 1);
        newPlayers.splice(newIndex, 0, removedPlayer);
        setPlayers(newPlayers);
      };

      const addPlayer = (name, initials) => {
        if (!name || !initials || initials.length !== 1) {
          setModalMessage("Bitte gib einen Spielernamen und ein einbuchstabiges Kürzel ein.");
          setShowModal(true);
          return;
        }
        if (players.some(p => p.name === name)) {
          setModalMessage("Dieser Spieler ist bereits hinzugefügt.");
          setShowModal(true);
          return;
        }
        if (players.some(p => p.initials === initials)) {
          setModalMessage("Dieses Kürzel ist bereits vergeben.");
          setShowModal(true);
          return;
        }
        if (players.length >= 4) {
          setNewPlayerName(name);
          setNewPlayerInitials(initials);
          setShowReplaceModal(true);
          return;
        }

        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus, currentDealer });
        const newPlayer = { name, initials };
        setPlayers([...players, newPlayer]);
        setPlayerSoloStatus(prev => ({ ...prev, [name]: { ...initialPlayerSoloStatus } }));
        setNewPlayerName('');
        setNewPlayerInitials('');
      };

      const replacePlayer = () => {
        if (!newPlayerName || !newPlayerInitials || !playerToReplace || newPlayerInitials.length !== 1) {
          setModalMessage("Bitte wähle einen Spieler zum Ersetzen und gib einen neuen Namen und ein einbuchstabiges Kürzel ein.");
          setShowModal(true);
          return;
        }
        if (players.some(p => p.name === newPlayerName)) {
          setModalMessage("Der neue Spielername ist bereits vorhanden.");
          setShowModal(true);
          return;
        }
        if (players.some(p => p.initials === newPlayerInitials)) {
          setModalMessage("Das neue Kürzel ist bereits vergeben.");
          setShowModal(true);
          return;
        }

        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus, currentDealer });

        const newPlayers = players.map(p => p.name === playerToReplace ? { name: newPlayerName, initials: newPlayerInitials } : p);
        const newGameHistory = gameHistory.map(game => ({
          ...game,
          dealer: game.dealer === playerToReplace ? newPlayerName : game.dealer,
          winner: game.winner.map(p => p === playerToReplace ? newPlayerName : p),
          loser: game.loser.map(p => p === playerToReplace ? newPlayerName : p),
          playerScores: Object.keys(game.playerScores).reduce((acc, p) => ({
            ...acc,
            [p === playerToReplace ? newPlayerName : p]: game.playerScores[p],
          }), {}),
        }));
        setPlayers(newPlayers);
        setGameHistory(newGameHistory);
        setPlayerSoloStatus(prev => {
          const newStatus = { ...prev };
          delete newStatus[playerToReplace];
          newStatus[newPlayerName] = { ...initialPlayerSoloStatus };
          return newStatus;
        });
        if (currentDealer === playerToReplace) {
          setCurrentDealer(newPlayerName);
        }
        setShowReplaceModal(false);
        setNewPlayerName('');
        setNewPlayerInitials('');
        setPlayerToReplace('');
      };

      const removePlayer = (playerName) => {
        setModalMessage(`Möchtest du Spieler "${playerName}" wirklich entfernen? Alle zugehörigen Spieldaten bleiben erhalten, aber der Spieler wird nicht mehr in der Liste angezeigt.`);
        setModalCallback(() => () => {
          saveStateToHistory({ players, pot, gameHistory, playerSoloStatus, currentDealer });
          const updatedPlayers = players.filter(p => p.name !== playerName);
          setPlayers(updatedPlayers);
          setPlayerSoloStatus(prev => {
            const newStatus = { ...prev };
            delete newStatus[playerName];
            return newStatus;
          });
          if (currentDealer === playerName) {
            setCurrentDealer(null);
          }
        });
        setShowModal(true);
      };

      const calculateNextDealer = (lastDealer, playersList, gameType, winningPlayers, losingPlayers, vorgefuehrtePlayer) => {
        if (!lastDealer || playersList.length === 0) return null;

        const isSoloGame = gameType.includes('solo') || gameType === 'schlanker_martin' || gameType === 'rote_luise' || gameType.startsWith('pflichtsolo') || gameType.startsWith('lustling');

        if (isSoloGame) {
          return lastDealer;
        }

        let lastDealerIndex = playersList.findIndex(p => p.name === lastDealer);
        let nextDealerIndex = (lastDealerIndex + 1) % playersList.length;
        let nextDealer = playersList[nextDealerIndex].name;

        const isVorgefuehrtInLastGame = gameType === 'normal' && losingPlayers.length === 1 && winningPlayers.length === playersList.length - 1 && losingPlayers[0] === nextDealer;

        if (isVorgefuehrtInLastGame) {
          nextDealerIndex = (nextDealerIndex + 1) % playersList.length;
          nextDealer = playersList[nextDealerIndex].name;
        }

        if (vorgefuehrtePlayer && nextDealer === vorgefuehrtePlayer) {
          nextDealerIndex = (nextDealerIndex + 1) % playersList.length;
          nextDealer = playersList[nextDealerIndex].name;
        }

        return nextDealer;
      };

      const addGame = () => {
        const errors = [];
        let calculatedLosingPlayers = players.filter(p => !winningPlayers.includes(p.name)).map(p => p.name);
        const isSoloGame = gameType.includes('solo') || gameType === 'schlanker_martin' || gameType === 'rote_luise' || gameType.startsWith('pflichtsolo') || gameType.startsWith('lustling');

        if (players.length < 4) errors.push("Mindestens 4 Spieler sind erforderlich.");
        if (!currentDealer) errors.push("Bitte wähle zuerst den 'Ersten Geber am Abend' aus.");
        if (winningPlayers.length === 0) errors.push("Bitte wähle mindestens einen Gewinner aus.");
        if (isNaN(points) || points < 0 || points > 240) errors.push("Punkte müssen zwischen 0 und 240 liegen.");
        if (gameType === 'normal' && winningPlayers.length !== 2) errors.push("Normalspiel erfordert genau 2 Gewinner.");
        if (isSoloGame) {
          if (winningPlayers.length === 1) {
            calculatedLosingPlayers = players.filter(p => p.name !== winningPlayers[0]).map(p => p.name);
          } else if (winningPlayers.length === 3) {
            calculatedLosingPlayers = players.filter(p => !winningPlayers.includes(p.name)).map(p => p.name);
            if (calculatedLosingPlayers.length !== 1) {
              errors.push("Für ein verlorenes Solo müssen genau 3 Gewinner ausgewählt werden, um den einen Verlierer zu bestimmen.");
            }
          } else {
            errors.push("Für ein Solo muss entweder genau 1 Gewinner (Soloist gewinnt) oder genau 3 Gewinner (Soloist verliert) ausgewählt werden.");
          }
        }
        if (gameType === 'schlanker_martin' && noStichMade && points !== 0) {
          errors.push("Für 'Kein Stich gemacht' bei Schlanker Martin müssen die Punkte 0 sein.");
        }
        if (pot <= 0 && !gameType.startsWith('pflichtsolo')) {
          const incompletePlayers = players.filter(p => !playerSoloStatus[p.name].knochenloser || !playerSoloStatus[p.name].bilder || !playerSoloStatus[p.name].farbe);
          if (incompletePlayers.length > 0) {
            errors.push(`Pot leer! Nur Pflichtsoli dürfen gespielt werden: ${incompletePlayers.map(p => p.initials).join(', ')}`);
          }
        }
        if (gameType.startsWith('pflichtsolo')) {
          const soloist = winningPlayers.length === 1 ? winningPlayers[0] : calculatedLosingPlayers[0];
          const soloCategory = gameType.split('_')[1];
          if (playerSoloStatus[soloist]?.[soloCategory]) {
            errors.push(`"${soloist}" hat das Pflichtsolo "${soloCategory.charAt(0).toUpperCase() + soloCategory.slice(1)}" bereits gespielt.`);
          }
        }
        if (errors.length > 0) {
          setModalMessage(errors.join(' '));
          setShowModal(true);
          return;
        }

        const potChange = calculatePotChange(gameType, winningPlayers, ansagen, sonderpunkte);
        const playerScores = calculateIndividualGameScores(gameType, winningPlayers, calculatedLosingPlayers, ansagen, sonderpunkte, noStichMade, points);

        const newGame = {
          timestamp: new Date().toISOString(),
          dealer: currentDealer,
          gameType,
          winner: winningPlayers,
          loser: calculatedLosingPlayers,
          points,
          ansagen: Object.keys(ansagen).filter(key => ansagen[key]).map(key => ({
            type: key,
            players: ansagenPlayers[key]
          })),
          sonderpunkte: Object.entries(sonderpunkte)
            .filter(([key, value]) => value > 0 || (key === 'SchlankerMartinSonderpunkt' && value))
            .map(([key, value]) => `${key}:${value}`),
          noStichMade,
          potChange,
          playerScores,
          potAfterGame: pot - potChange,
        };

        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus, currentDealer });

        let updatedGameHistory;
        let newPotValue;

        if (editingGameIndex !== null) {
          updatedGameHistory = [...gameHistory];
          updatedGameHistory[editingGameIndex] = newGame;
          setGameHistory(updatedGameHistory);
          newPotValue = 120;
          updatedGameHistory.forEach(game => {
            newPotValue -= game.potChange;
          });
          setPot(newPotValue);
          setEditingGameIndex(null);
        } else {
          updatedGameHistory = [...gameHistory, newGame];
          setGameHistory(updatedGameHistory);
          newPotValue = pot - potChange;
          setPot(newPotValue);
        }

        const nextDealer = calculateNextDealer(currentDealer, players, gameType, winningPlayers, calculatedLosingPlayers, vorgefuehrtePlayer);
        setCurrentDealer(nextDealer);

        setGameType('normal');
        setWinningPlayers([]);
        set