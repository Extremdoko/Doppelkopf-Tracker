<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Extrem-Doppelkopf-Tracker V3</title>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7.22.9/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, collection, query, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    window.firebase = { initializeApp, getAuth, signInAnonymously, onAuthStateChanged, getFirestore, doc, getDoc, setDoc, collection, query, getDocs, deleteDoc };
  </script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f2f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      background-color: #ffffff;
      border-radius: 15px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      padding: 30px;
      width: 100%;
      max-width: 1000px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .btn {
      padding: 10px 20px;
      border-radius: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease-in-out;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
    .btn-primary {
      background-color: #4CAF50;
      color: white;
      border: none;
    }
    .btn-primary:hover {
      background-color: #45a049;
      transform: translateY(-2px);
    }
    .btn-secondary {
      background-color: #007bff;
      color: white;
      border: none;
    }
    .btn-secondary:hover {
      background-color: #0056b3;
      transform: translateY(-2px);
    }
    .btn-danger {
      background-color: #dc3545;
      color: white;
      border: none;
    }
    .btn-danger:hover {
      background-color: #c82333;
      transform: translateY(-2px);
    }
    .btn-warning { /* New style for warning button (yellow) */
      background-color: #ffc107;
      color: #212529; /* Dark text for contrast */
      border: none;
    }
    .btn-warning:hover {
      background-color: #e0a800;
      transform: translateY(-2px);
    }
    input[type="text"], input[type="number"], input[type="time"] {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 1rem;
      width: 100%;
      box-sizing: border-box;
    }
    input[type="number"].narrow {
      width: 4rem; /* Narrower input for sonderpunkte */
    }
    select {
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      font-size: 1rem;
      width: 100%;
      box-sizing: border-box;
      background-color: white;
    }
    .card {
      background-color: #f9f9f9;
      border-radius: 10px;
      padding: 20px;
      box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
    }
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0,0,0,0.4);
      justify-content: center;
      align-items: center;
      transition: opacity 0.3s ease-in-out;
    }
    .modal-content {
      background-color: #fefefe;
      margin: auto;
      padding: 20px;
      border-radius: 15px;
      width: 80%;
      max-width: 500px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
      transform: translateY(0);
      transition: transform 0.3s ease-in-out;
    }
    .close-button {
      color: #aaa;
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }
    .close-button:hover {
      color: black;
    }
    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }
    select[multiple] {
      min-height: 100px;
    }
    .game-history-table {
      width: 100%;
      text-align: center;
      overflow-x: auto;
      display: block;
    }
    .game-history-table th, .game-history-table td {
      padding: 8px;
      border-bottom: 1px solid #e2e8f0;
    }
    .game-history-table th {
      font-weight: 600;
      background-color: #e2e8f0;
      position: sticky;
      top: 0;
    }
    .game-history-table tbody tr:hover {
      background-color: #f0f4f8;
    }
    .points-positive {
      color: #10b981;
      font-weight: bold;
    }
    .points-negative {
      color: #ef4444;
      font-weight: bold;
    }
    .text-darkblue-bold {
      color: #1a202c;
      font-weight: bold;
    }
    .solo-indicators {
      display: flex;
      gap: 4px;
      margin-top: 4px;
    }
    .solo-indicator {
      font-size: 0.75rem;
      font-weight: 600;
    }
    .solo-indicator.completed {
      color: #10b981;
    }
    .solo-indicator.pending {
      color: #9ca3af;
    }
    .player-header-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2px;
      box-sizing: border-box;
    }
    .player-header-content.player-header-completed-solos {
      border: 2px solid #10b981;
      border-radius: 8px;
      margin: -2px;
    }
    .game-history-table th {
      border-bottom: none;
    }
    .game-history-table tbody tr:first-child td {
      border-top: 1px solid #e2e8f0;
    }
    .ranking-row {
      border-top: 2px solid #6b7280;
      margin-top: 10px;
      background-color: #e5e7eb;
    }
    .main-title-container {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .main-title-symbol {
      font-size: 2.5rem;
      color: #1a202c;
    }
    input:invalid {
      border-color: #ef4444;
    }
    /* Style for wrapping text in details column */
    .details-cell {
      white-space: normal; /* Allow text to wrap */
      word-break: break-word; /* Break long words */
      max-width: 150px; /* Adjust as needed to control column width */
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect } = React;
    const { initializeApp, getAuth, signInAnonymously, onAuthStateChanged, getFirestore, doc, getDoc, setDoc, collection, query, getDocs, deleteDoc } = window.firebase;

    // TypeScript-like interfaces
    const initialPlayerSoloStatus = {
      knochenloser: false,
      bilder: false,
      farbe: false,
    };

    const defaultPlayers = ['Krister', 'Christoph', 'Sine', 'Tommy'];

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyD7xd92-_1fOhrzotajFebVk73a2rrFgWo",
      authDomain: "doppelkopf-tracker-db.firebaseapp.com",
      projectId: "doppelkopf-tracker-db",
      storageBucket: "doppelkopf-tracker-db.firebasestorage.app",
      messagingSenderId: "712822307922",
      appId: "1:712822307922:web:837e7da77e0b2e1102338b",
      measurementId: "G-XK4ER1LPRF"
    };

    const App = () => {
      const [players, setPlayers] = useState([]);
      const [pot, setPot] = useState(120);
      const [gameHistory, setGameHistory] = useState([]);
      const [playerSoloStatus, setPlayerSoloStatus] = useState({});
      const [userId, setUserId] = useState('anonymous-local-user');
      const [currentSessionId, setCurrentSessionId] = useState(null);
      const [sessions, setSessions] = useState([]);
      const [gameType, setGameType] = useState('normal');
      const [winningPlayers, setWinningPlayers] = useState([]);
      const [points, setPoints] = useState(120);
      const [ansagen, setAnsagen] = useState({
        GegenDieAlten: false,
        Re: false,
        Kontra: false,
        ReKontra: false,
        Keine90: false,
        Keine60: false,
        Keine30: false,
        Keine0: false,
      });
      const [sonderpunkte, setSonderpunkte] = useState({
        DoppelkopfWinner: 0,
        DoppelkopfLoser: 0,
        KarlchenMuellerWinner: 0,
        KarlchenMuellerLoser: 0,
        FuchsGefangenWinner: 0,
        FuchsGefangenLoser: 0,
        FuchsMachtLetztenStichWinner: 0,
        FuchsMachtLetztenStichLoser: 0,
        SchlankerMartinSonderpunkt: false,
      });
      const [noStichMade, setNoStichMade] = useState(false);
      const [timeBomb, setTimeBomb] = useState('');
      const [modalMessage, setModalMessage] = useState('');
      const [showModal, setShowModal] = useState(false);
      const [modalCallback, setModalCallback] = useState(null);
      const [showReplaceModal, setShowReplaceModal] = useState(false);
      const [newPlayerName, setNewPlayerName] = useState('');
      const [playerToReplace, setPlayerToReplace] = useState('');
      
      // State for Undo/Redo
      const [historyStates, setHistoryStates] = useState([]);
      const [historyPointer, setHistoryPointer] = useState(-1); // -1 means no state yet

      const [editingGameIndex, setEditingGameIndex] = useState(null); // State for editing

      const [isFirebaseInitialized, setIsFirebaseInitialized] = useState(false);
      const [dbInstance, setDbInstance] = useState(null);
      const [authInstance, setAuthInstance] = useState(null);

      // Function to apply a historical state
      const applyState = (state) => {
          setPlayers(state.players);
          setPot(state.pot);
          setGameHistory(state.gameHistory);
          setPlayerSoloStatus(state.playerSoloStatus);
      };

      // Function to save current state to history
      const saveStateToHistory = (currentState) => {
          const newHistory = historyStates.slice(0, historyPointer + 1);
          setHistoryStates([...newHistory, currentState]);
          setHistoryPointer(newHistory.length);
      };

      // Firebase setup
      useEffect(() => {
        let app, db, auth;
        try {
          app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);
          setIsFirebaseInitialized(true);
          setDbInstance(db);
          setAuthInstance(auth);

          onAuthStateChanged(auth, async (user) => {
            if (user) {
              setUserId(user.uid);
              await loadLastSession(db, user.uid);
              await loadAllSessions(db, user.uid);
            } else {
              await signInAnonymously(auth);
            }
          });
        } catch (e) {
          console.warn("Firebase initialization failed. Using local storage.", e);
          setPlayers(defaultPlayers);
          defaultPlayers.forEach(p => setPlayerSoloStatus(prev => ({ ...prev, [p]: { ...initialPlayerSoloStatus } })));
          // Initialize history with default state if Firebase fails
          saveStateToHistory({ players: defaultPlayers, pot: 120, gameHistory: [], playerSoloStatus: defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {}) });
        }
      }, []);

      // Effect to save session whenever relevant state changes
      useEffect(() => {
        if (historyPointer > -1) { // Only save if there's a state to save
          saveCurrentSession(dbInstance, false);
        }
      }, [historyStates, historyPointer, dbInstance]);

      // Effect to recalculate solo status whenever gameHistory or players change
      useEffect(() => {
          recalculateSoloStatus();
      }, [gameHistory, players]);


      // Debounce function
      const debounce = (fn, wait) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), wait);
        };
      };

      // Save session
      const saveCurrentSession = debounce(async (db, showSuccess = false) => {
        const sessionData = { players, pot, gameHistory, playerSoloStatus, lastUpdated: new Date().toISOString() };
        if (isFirebaseInitialized && db && userId) {
          try {
            const docId = currentSessionId || `session_${Date.now()}`;
            const sessionDocRef = doc(db, `artifacts/doppelkopf-tracker/users/${userId}/doppelkopf_sessions`, docId);
            await setDoc(sessionDocRef, sessionData);
            setCurrentSessionId(docId); // Ensure currentSessionId is set after first save
            if (showSuccess) {
              setModalMessage("Sitzung erfolgreich gespeichert!");
              setShowModal(true);
            }
          } catch (e) {
            setModalMessage(`Fehler beim Speichern: ${e.message}`);
            setShowModal(true);
          }
        } else {
          localStorage.setItem('doppelkopf_session', JSON.stringify(sessionData));
          if (showSuccess) {
            setModalMessage("Sitzung lokal gespeichert!");
            setShowModal(true);
          }
        }
      }, 1000);

      // Load last session
      const loadLastSession = async (db, userId) => {
        if (isFirebaseInitialized && db && userId) {
          try {
            const sessionsColRef = collection(db, `artifacts/doppelkopf-tracker/users/${userId}/doppelkopf_sessions`);
            const q = query(sessionsColRef);
            const querySnapshot = await getDocs(q);
            let latestSession = null;
            let latestTimestamp = 0;

            querySnapshot.forEach(doc => {
              const data = doc.data();
              const timestamp = new Date(data.lastUpdated).getTime();
              if (timestamp > latestTimestamp) {
                latestTimestamp = timestamp;
                latestSession = { id: doc.id, ...data };
              }
            });

            if (latestSession) {
              setCurrentSessionId(latestSession.id);
              applyState({
                  players: latestSession.players || defaultPlayers,
                  pot: latestSession.pot || 120,
                  gameHistory: latestSession.history || [],
                  playerSoloStatus: latestSession.playerSoloStatus || defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
              });
              // Initialize history with loaded state
              setHistoryStates([
                  { players: latestSession.players || defaultPlayers,
                    pot: latestSession.pot || 120,
                    gameHistory: latestSession.history || [],
                    playerSoloStatus: latestSession.playerSoloStatus || defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
                  }
              ]);
              setHistoryPointer(0);
            } else {
              startNewSession(db, false);
            }
          } catch (e) {
            setModalMessage(`Fehler beim Laden der letzten Sitzung: ${e.message}`);
            setShowModal(true);
          }
        } else {
          const savedSession = localStorage.getItem('doppelkopf_session');
          if (savedSession) {
            const data = JSON.parse(savedSession);
            applyState({
                players: data.players || defaultPlayers,
                pot: data.pot || 120,
                gameHistory: data.history || [],
                playerSoloStatus: data.playerSoloStatus || defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
            });
            setHistoryStates([
                { players: data.players || defaultPlayers,
                  pot: data.pot || 120,
                  gameHistory: data.history || [],
                  playerSoloStatus: data.playerSoloStatus || defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
                }
            ]);
            setHistoryPointer(0);
          } else {
            setPlayers(defaultPlayers);
            defaultPlayers.forEach(p => setPlayerSoloStatus(prev => ({ ...prev, [p]: { ...initialPlayerSoloStatus } })));
            // Initialize history with default state
            saveStateToHistory({ players: defaultPlayers, pot: 120, gameHistory: [], playerSoloStatus: defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {}) });
          }
        }
      };

      // Load all sessions
      const loadAllSessions = async (db, userId) => {
        if (isFirebaseInitialized && db && userId) {
          try {
            const sessionsColRef = collection(db, `artifacts/doppelkopf-tracker/users/${userId}/doppelkopf_sessions`);
            const q = query(sessionsColRef);
            const querySnapshot = await getDocs(q);
            const sessionList = [];
            querySnapshot.forEach(doc => sessionList.push({ id: doc.id, ...doc.data() }));
            setSessions(sessionList);
          } catch (e) {
            setModalMessage(`Fehler beim Laden aller Sitzungen: ${e.message}`);
            setShowModal(true);
          }
        }
      };

      // Start new session
      const startNewSession = (db, showSuccess = true) => {
        setCurrentSessionId(`session_${Date.now()}`);
        const newState = {
            players: defaultPlayers,
            pot: 120,
            gameHistory: [],
            playerSoloStatus: defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
        };
        applyState(newState);
        setHistoryStates([newState]);
        setHistoryPointer(0);
        if (db) saveCurrentSession(db, showSuccess);
      };

      // Delete session
      const deleteSession = async (sessionId) => {
        if (isFirebaseInitialized && dbInstance && userId) {
          try {
            await deleteDoc(doc(dbInstance, `artifacts/doppelkopf-tracker/users/${userId}/doppelkopf_sessions`, sessionId));
            setSessions(sessions.filter(s => s.id !== sessionId));
            if (currentSessionId === sessionId) startNewSession(dbInstance, false);
          } catch (e) {
            setModalMessage(`Fehler beim Löschen der Sitzung: ${e.message}`);
            setShowModal(true);
          }
        }
      };

      // Calculate pot change
      const calculatePotChange = (gameType, winningPlayers, ansagen, sonderpunkte) => {
        if (gameType !== 'normal') return 0; // Solos don't directly affect the pot
        let pointsPerWinningPlayer = 1; // Base: Keine 120 = 1 Punkt

        if (ansagen.Re) pointsPerWinningPlayer += 2;
        if (ansagen.Kontra) pointsPerWinningPlayer += 2;
        if (ansagen.GegenDieAlten) pointsPerWinningPlayer += 1; // Gegen die Alten is usually 1 point
        if (ansagen.ReKontra) pointsPerWinningPlayer += 2; // Assuming ReKontra is an additional 2 points

        if (ansagen.Keine90) pointsPerWinningPlayer += 2; // 1 for angesagt, 1 for erreicht
        if (ansagen.Keine60) pointsPerWinningPlayer += 2; // 1 angesagt, 1 erreicht
        if (ansagen.Keine30) pointsPerWinningPlayer += 2; // 1 angesagt, 1 erreicht
        if (ansagen.Keine0) pointsPerWinningPlayer += 2; // 1 angesagt, 1 erreicht

        pointsPerWinningPlayer += sonderpunkte.DoppelkopfWinner;
        pointsPerWinningPlayer += sonderpunkte.KarlchenMuellerWinner;
        pointsPerWinningPlayer += sonderpunkte.FuchsGefangenWinner;
        pointsPerWinningPlayer += sonderpunkte.FuchsMachtLetztenStichWinner;

        return pointsPerWinningPlayer * winningPlayers.length; // For normal game, usually 2 winners
      };

      // Calculate individual game scores
      const calculateIndividualGameScores = (gameType, winningPlayers, losingPlayers, ansagen, sonderpunkte, noStichMade, points) => {
        const playerScores = players.reduce((acc, p) => ({ ...acc, [p]: 0 }), {});
        const isWonSolo = winningPlayers.length === 1 && losingPlayers.length === 3;
        const isLostSolo = losingPlayers.length === 1 && players.length === 4 && winningPlayers.length === 3; // Ensure 4 players for lost solo
        
        let basePoints = 0;
        let winnerBonus = 0;
        let loserPenalty = 0;

        // Sonderpunkte (apply to normal and general solos, and Rote Luise if won)
        winnerBonus += sonderpunkte.DoppelkopfWinner;
        winnerBonus += sonderpunkte.KarlchenMuellerWinner;
        winnerBonus += sonderpunkte.FuchsGefangenWinner;
        winnerBonus += sonderpunkte.FuchsMachtLetztenStichWinner;

        loserPenalty += sonderpunkte.DoppelkopfLoser;
        loserPenalty += sonderpunkte.KarlchenMuellerLoser;
        loserPenalty += sonderpunkte.FuchsGefangenLoser;
        loserPenalty += sonderpunkte.FuchsMachtLetztenStichLoser;


        if (gameType === 'normal') {
            basePoints = 1; // Base for Keine 120

            // Ansagen for normal game
            if (ansagen.GegenDieAlten) basePoints += 1;
            if (ansagen.Re) basePoints += 2;
            if (ansagen.Kontra) basePoints += 2;
            if (ansagen.ReKontra) basePoints += 2;
            if (ansagen.Keine90) basePoints += 2;
            if (ansagen.Keine60) basePoints += 2;
            if (ansagen.Keine30) basePoints += 2;
            if (ansagen.Keine0) basePoints += 2;

            winningPlayers.forEach(p => playerScores[p] = basePoints + winnerBonus);
            losingPlayers.forEach(p => playerScores[p] = -(basePoints + loserPenalty));

        } else if (gameType === 'schlanker_martin') {
            if (noStichMade) { // Special case: No Stich Made
                const smPointsPerOpponent = sonderpunkte.SchlankerMartinSonderpunkt ? 2 : 1; // 2 if 'Ein Kontrist keinen Stich', 1 if 'Alle Spieler einen Stich'
                if (isWonSolo) {
                    playerScores[winningPlayers[0]] = smPointsPerOpponent * 3;
                    losingPlayers.forEach(p => playerScores[p] = -smPointsPerOpponent);
                } else if (isLostSolo) {
                    playerScores[losingPlayers[0]] = -(smPointsPerOpponent * 3);
                    winningPlayers.forEach(p => playerScores[p] = smPointsPerOpponent);
                }
            } else { // Normal Schlanker Martin solo (not 'no stich made')
                basePoints = 1; // Base for Keine 120
                if (ansagen.GegenDieAlten) basePoints += 1;
                if (ansagen.Re) basePoints += 2;
                if (ansagen.Kontra) basePoints += 2;
                if (ansagen.ReKontra) basePoints += 2;
                if (ansagen.Keine90) basePoints += 2;
                if (ansagen.Keine60) basePoints += 2;
                if (ansagen.Keine30) basePoints += 2;
                if (ansagen.Keine0) basePoints += 2;

                if (isWonSolo) {
                    playerScores[winningPlayers[0]] = (basePoints + winnerBonus) * 3;
                    losingPlayers.forEach(p => playerScores[p] = -(basePoints + loserPenalty));
                } else if (isLostSolo) {
                    playerScores[losingPlayers[0]] = -(basePoints + loserPenalty) * 3;
                    winningPlayers.forEach(p => playerScores[p] = (basePoints + winnerBonus));
                }
            }
        } else if (gameType === 'rote_luise') {
            let rlPoints = 1; // Base for Keine 120

            // Rote Luise points from ansagen (Keine X)
            if (ansagen.Keine90) rlPoints += 1;
            if (ansagen.Keine60) rlPoints += 1;
            if (ansagen.Keine30) rlPoints += 1;
            if (ansagen.Keine0) rlPoints += 1;

            if (isWonSolo) {
                playerScores[winningPlayers[0]] = (rlPoints + winnerBonus) * 3;
                losingPlayers.forEach(p => playerScores[p] = -(rlPoints + loserPenalty));
            } else if (isLostSolo) {
                playerScores[losingPlayers[0]] = -(rlPoints + loserPenalty) * 3;
                winningPlayers.forEach(p => playerScores[p] = (rlPoints + winnerBonus));
            }
        } else { // All other solos (Pflichtsolo, Lüstling, Stilles Solo)
            basePoints = 1; // Base for Keine 120
            if (ansagen.GegenDieAlten) basePoints += 1;
            if (ansagen.Re) basePoints += 2;
            if (ansagen.Kontra) basePoints += 2;
            if (ansagen.ReKontra) basePoints += 2;
            if (ansagen.Keine90) basePoints += 2;
            if (ansagen.Keine60) basePoints += 2;
            if (ansagen.Keine30) basePoints += 2;
            if (ansagen.Keine0) basePoints += 2;

            if (isWonSolo) {
                playerScores[winningPlayers[0]] = (basePoints + winnerBonus) * 3;
                losingPlayers.forEach(p => playerScores[p] = -(basePoints + loserPenalty));
            } else if (isLostSolo) {
                playerScores[losingPlayers[0]] = -(basePoints + loserPenalty) * 3;
                winningPlayers.forEach(p => playerScores[p] = (basePoints + winnerBonus));
            }
        }
        return playerScores;
      };

      // Recalculate Pflichtsolo status
      const recalculateSoloStatus = () => {
        const newStatus = players.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {});
        gameHistory.forEach(game => {
          if (game.gameType.startsWith('pflichtsolo')) {
            const isWonSolo = game.winner.length === 1 && game.loser.length === 3;
            const isLostSolo = game.loser.length === 1 && game.winner.length === 3;
            const soloist = isWonSolo ? game.winner[0] : isLostSolo ? game.loser[0] : null;
            if (soloist && newStatus[soloist]) { // Check if soloist exists in current players
              const soloCategory = game.gameType.split('_')[1];
              if (newStatus[soloist][soloCategory] !== undefined) { // Check if category exists
                 newStatus[soloist][soloCategory] = true;
              }
            }
          }
        });
        setPlayerSoloStatus(newStatus);
      };

      // Add player
      const addPlayer = (name) => {
        if (!name) {
          setModalMessage("Bitte gib einen Spielernamen ein.");
          setShowModal(true);
          return;
        }
        if (players.includes(name)) {
          setModalMessage("Dieser Spieler ist bereits hinzugefügt.");
          setShowModal(true);
          return;
        }
        if (players.length >= 4) {
          setNewPlayerName(name);
          setShowReplaceModal(true);
          return;
        }
        
        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus }); // Save state before adding player
        setPlayers([...players, name]);
        setPlayerSoloStatus(prev => ({ ...prev, [name]: { ...initialPlayerSoloStatus } }));
      };

      // Replace player
      const replacePlayer = () => {
        if (!newPlayerName || !playerToReplace) {
          setModalMessage("Bitte wähle einen Spieler zum Ersetzen und gib einen neuen Namen ein.");
          setShowModal(true);
          return;
        }
        if (players.includes(newPlayerName)) {
          setModalMessage("Der neue Spielername ist bereits vorhanden.");
          setShowModal(true);
          return;
        }

        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus }); // Save state before replacing player

        const newPlayers = players.map(p => p === playerToReplace ? newPlayerName : p);
        const newGameHistory = gameHistory.map(game => ({
          ...game,
          winner: game.winner.map(p => p === playerToReplace ? newPlayerName : p),
          loser: game.loser.map(p => p === playerToReplace ? newPlayerName : p),
          playerScores: Object.keys(game.playerScores).reduce((acc, p) => ({
            ...acc,
            [p === playerToReplace ? newPlayerName : p]: game.playerScores[p],
          }), {}),
        }));
        setPlayers(newPlayers);
        setGameHistory(newGameHistory);
        setPlayerSoloStatus(prev => {
          const newStatus = { ...prev, [newPlayerName]: { ...initialPlayerSoloStatus } };
          delete newStatus[playerToReplace];
          return newStatus;
        });
        setShowReplaceModal(false);
        setNewPlayerName('');
        setPlayerToReplace('');
      };

      // Remove player
      const removePlayer = (playerToRemove) => {
        setModalMessage(`Möchtest du Spieler "${playerToRemove}" wirklich entfernen? Alle zugehörigen Spieldaten bleiben erhalten, aber der Spieler wird nicht mehr in der Liste angezeigt.`);
        setModalCallback(() => () => {
            saveStateToHistory({ players, pot, gameHistory, playerSoloStatus }); // Save state before removing player

            const updatedPlayers = players.filter(p => p !== playerToRemove);
            // No need to filter gameHistory, just the player list and solo status
            setPlayers(updatedPlayers);
            setPlayerSoloStatus(prev => {
                const newStatus = { ...prev };
                delete newStatus[playerToRemove];
                return newStatus;
            });
            // Recalculate solo status is handled by useEffect
        });
        setShowModal(true);
      };


      // Add/Edit game
      const addGame = () => {
        if (players.length < 4) {
          setModalMessage("Mindestens 4 Spieler erforderlich.");
          setShowModal(true);
          return;
        }
        if (winningPlayers.length === 0 || isNaN(points) || points < 0) {
          setModalMessage("Bitte Gewinner und Punkte korrekt ausfüllen.");
          setShowModal(true);
          return;
        }
        if (gameType === 'normal' && winningPlayers.length !== 2) {
          setModalMessage("Normalspiel erfordert genau 2 Gewinner.");
          setShowModal(true);
          return;
        }
        // Determine losing players based on selected winners and total players
        const losingPlayers = players.filter(p => !winningPlayers.includes(p));

        if ((gameType.includes('solo') || gameType === 'schlanker_martin' || gameType === 'rote_luise' || gameType.startsWith('pflichtsolo') || gameType.startsWith('lustling')) && (winningPlayers.length !== 1 || losingPlayers.length !== 3)) {
            setModalMessage("Für ein Solo muss genau 1 Gewinner und 3 Verlierer ausgewählt werden.");
            setShowModal(true);
            return;
        }

        if (gameType === 'schlanker_martin' && noStichMade && points !== 0) {
          setModalMessage("Für 'Kein Stich gemacht' bei Schlanker Martin müssen die Punkte 0 sein.");
          setShowModal(true);
          return;
        }
        if (pot <= 0 && !gameType.startsWith('pflichtsolo')) {
          const incompletePlayers = players.filter(p => !playerSoloStatus[p].knochenloser || !playerSoloStatus[p].bilder || !playerSoloStatus[p].farbe);
          if (incompletePlayers.length > 0) {
            setModalMessage(`Pot leer! Nur Pflichtsoli dürfen gespielt werden: ${incompletePlayers.join(', ')}`);
            setShowModal(true);
            return;
          }
        }
        if (gameType.startsWith('pflichtsolo')) {
          const soloist = winningPlayers.length === 1 ? winningPlayers[0] : players.find(p => !winningPlayers.includes(p));
          const soloCategory = gameType.split('_')[1];
          if (playerSoloStatus[soloist]?.[soloCategory]) {
            setModalMessage(`"${soloist}" hat das Pflichtsolo "${soloCategory.charAt(0).toUpperCase() + soloCategory.slice(1)}" bereits gespielt.`);
            setShowModal(true);
            return;
          }
        }

        const potChange = calculatePotChange(gameType, winningPlayers, ansagen, sonderpunkte);
        const playerScores = calculateIndividualGameScores(gameType, winningPlayers, losingPlayers, ansagen, sonderpunkte, noStichMade, points);

        const newGame = {
          timestamp: new Date().toISOString(),
          gameType,
          winner: winningPlayers,
          loser: losingPlayers,
          points, // Punkte der Gewinner
          ansagen: Object.keys(ansagen).filter(key => ansagen[key]),
          sonderpunkte: Object.entries(sonderpunkte)
            .filter(([key, value]) => value > 0 || (key === 'SchlankerMartinSonderpunkt' && value))
            .map(([key, value]) => `${key}:${value}`),
          noStichMade,
          potChange,
          playerScores,
          potAfterGame: pot - potChange,
        };

        saveStateToHistory({ players, pot, gameHistory, playerSoloStatus }); // Save state before modification

        if (editingGameIndex !== null) {
            const updatedGameHistory = [...gameHistory];
            updatedGameHistory[editingGameIndex] = newGame;
            setGameHistory(updatedGameHistory);
            // Recalculate pot from scratch based on new history
            let recalculatedPot = 120;
            updatedGameHistory.forEach(game => {
                recalculatedPot -= game.potChange;
            });
            setPot(recalculatedPot);
            setEditingGameIndex(null);
        } else {
            setGameHistory(prev => [...prev, newGame]);
            setPot(prevPot => prevPot - potChange);
        }

        // recalculateSoloStatus is now handled by useEffect
        // reset inputs
        resetGameInputForm();
      };

      // Delete game
      const deleteGame = (index) => {
        setModalMessage("Möchtest du dieses Spiel wirklich löschen? Dies kann nicht rückgängig gemacht werden.");
        setModalCallback(() => () => {
            saveStateToHistory({ players, pot, gameHistory, playerSoloStatus }); // Save state before deletion
            const deletedGame = gameHistory[index];
            const updatedGameHistory = gameHistory.filter((_, i) => i !== index);
            setGameHistory(updatedGameHistory);
            // Recalculate pot from scratch based on new history
            let recalculatedPot = 120;
            updatedGameHistory.forEach(game => {
                recalculatedPot -= game.potChange;
            });
            setPot(recalculatedPot);
            // recalculateSoloStatus is now handled by useEffect
        });
        setShowModal(true);
      };

      // Edit game (populate form)
      const editGame = (index) => {
        const gameToEdit = gameHistory[index];
        setEditingGameIndex(index);
        
        setGameType(gameToEdit.gameType);
        setWinningPlayers(gameToEdit.winner);
        setPoints(gameToEdit.points);
        
        // Reconstruct ansagen object from array
        const newAnsagen = {
            GegenDieAlten: gameToEdit.ansagen.includes('GegenDieAlten'),
            Re: gameToEdit.ansagen.includes('Re'),
            Kontra: gameToEdit.ansagen.includes('Kontra'),
            ReKontra: gameToEdit.ansagen.includes('ReKontra'),
            Keine90: gameToEdit.ansagen.includes('Keine90'),
            Keine60: gameToEdit.ansagen.includes('Keine60'),
            Keine30: gameToEdit.ansagen.includes('Keine30'),
            Keine0: gameToEdit.ansagen.includes('Keine0'),
        };
        setAnsagen(newAnsagen);

        // Reconstruct sonderpunkte object from array
        const newSonderpunkte = {
            DoppelkopfWinner: 0, DoppelkopfLoser: 0, KarlchenMuellerWinner: 0, KarlchenMuellerLoser: 0,
            FuchsGefangenWinner: 0, FuchsGefangenLoser: 0, FuchsMachtLetztenStichWinner: 0, FuchsMachtLetztenStichLoser: 0,
            SchlankerMartinSonderpunkt: false,
        };
        gameToEdit.sonderpunkte.forEach(spString => {
            const [key, value] = spString.split(':');
            if (key === 'SchlankerMartinSonderpunkt') {
                newSonderpunkte[key] = true;
            } else if (newSonderpunkte.hasOwnProperty(key)) { // Only set if key exists
                newSonderpunkte[key] = parseInt(value);
            }
        });
        setSonderpunkte(newSonderpunkte);
        setNoStichMade(gameToEdit.noStichMade || false); 
      };

      // Reset game input form fields
      const resetGameInputForm = () => {
        setGameType('normal');
        setWinningPlayers([]);
        setPoints(120);
        setAnsagen({
          GegenDieAlten: false, Re: false, Kontra: false, ReKontra: false,
          Keine90: false, Keine60: false, Keine30: false, Keine0: false
        });
        setSonderpunkte({
          DoppelkopfWinner: 0, DoppelkopfLoser: 0, KarlchenMuellerWinner: 0, KarlchenMuellerLoser: 0,
          FuchsGefangenWinner: 0, FuchsGefangenLoser: 0, FuchsMachtLetztenStichWinner: 0, FuchsMachtLetztenStichLoser: 0,
          SchlankerMartinSonderpunkt: false,
        });
        setNoStichMade(false);
        setEditingGameIndex(null); // Ensure editing state is reset
      };


      // Undo action
      const undo = () => {
          if (historyPointer > 0) {
              const newPointer = historyPointer - 1;
              applyState(historyStates[newPointer]);
              setHistoryPointer(newPointer);
          }
      };

      // Redo action
      const redo = () => {
          if (historyPointer < historyStates.length - 1) {
              const newPointer = historyPointer + 1;
              applyState(historyStates[newPointer]);
              setHistoryPointer(newPointer);
          }
      };

      // Time bomb check
      useEffect(() => {
        if (!timeBomb) return;
        const [hours, minutes] = timeBomb.split(':');
        const timeBombDate = new Date();
        timeBombDate.setHours(hours, minutes, 0, 0);
        const interval = setInterval(() => {
          if (new Date() >= timeBombDate) {
            setModalMessage('Zeitzünder erreicht! Nur Pflichtsoli können gespielt werden.');
            setShowModal(true);
            setGameType('pflichtsolo_knochenloser'); // Force Pflichtsolo
          }
        }, 60000); // Check every minute
        return () => clearInterval(interval);
      }, [timeBomb]);

      // Auto-update Keine X checkboxes for Rote Luise lost solo
      useEffect(() => {
        const losingPlayers = players.filter(p => !winningPlayers.includes(p));
        if (gameType === 'rote_luise' && losingPlayers.length === 1) { // If a solo is lost (3 winners, 1 loser)
          setAnsagen(prev => ({
            ...prev,
            Keine90: points < 90,
            Keine60: points < 60,
            Keine30: points < 30,
            Keine0: points === 0,
          }));
        } else if (gameType !== 'rote_luise' && gameType !== 'schlanker_martin') { // Only reset if not Rote Luise or Schlanker Martin
            setAnsagen(prev => ({
                ...prev,
                Keine90: false,
                Keine60: false,
                Keine30: false,
                Keine0: false,
            }));
        }
      }, [points, winningPlayers, gameType, players]);


      // Render UI
      return (
        <div className="container">
          <div className="main-title-container mb-4">
            <span className="main-title-symbol">♠</span>
            <h1 className="text-3xl font-bold text-center text-darkblue-bold m-0">Extrem-Doppelkopf-Tracker V3</h1>
            <span className="main-title-symbol">♥</span>
          </div>

          {/* Pot Display */}
          <div className="card text-center bg-green-100 p-6 rounded-lg shadow-md">
            <h2 className="text-2xl font-semibold text-gray-700">Aktueller Pot</h2>
            <p className={`text-5xl font-bold ${pot <= 0 ? 'text-red-700' : 'text-green-700'}`}>{pot}</p>
          </div>

          {/* Player Management */}
          <div className="card">
            <h2 className="text-xl font-semibold text-gray-700 mb-3 text-center">Spieler verwalten</h2> {/* Centered heading */}
            <div className="flex flex-col sm:flex-row gap-3 mb-4 justify-center"> {/* Centered input and button */}
              <input
                type="text"
                placeholder="Spielername"
                value={newPlayerName}
                onChange={e => setNewPlayerName(e.target.value)}
                onKeyDown={e => e.key === 'Enter' && addPlayer(newPlayerName)}
                className="border p-2 rounded"
                aria-label="Neuer Spielername"
              />
              <button className="btn btn-primary" onClick={() => addPlayer(newPlayerName)} aria-label="Spieler austauschen"> {/* Button text changed */}
                Spieler austauschen
              </button>
            </div>
            <div className="flex flex-wrap gap-2 justify-center"> {/* Centered player tags */}
              {players.map(player => (
                <span key={player} className="bg-blue-200 text-blue-800 px-3 py-1 rounded-full flex items-center gap-2 font-bold"> {/* Added font-bold */}
                  {player}
                  <button
                    className="text-blue-600 hover:text-blue-900 font-bold"
                    onClick={() => removePlayer(player)}
                    aria-label={`Spieler ${player} entfernen`}
                  >
                    x
                  </button>
                </span>
              ))}
            </div>
          </div>

          {/* Time Bomb */}
          <div className="card">
            <h2 className="text-xl font-semibold text-gray-700 mb-3 text-center">Zeitzünder</h2>
            <div className="flex justify-center"> {/* Added flex container for centering */}
              <input
                type="time"
                value={timeBomb}
                onChange={e => setTimeBomb(e.target.value)}
                className="border p-2 rounded"
                aria-label="Zeitzünder setzen"
              />
            </div>
          </div>

          {/* Game Input */}
          <div className="card">
            <h2 className="text-xl font-semibold text-gray-700 mb-3 text-center">Spieltyp / Punkte der Gewinner / Ansagen / Sonderpunkte</h2> {/* Changed and centered heading */}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
              <div>
                <label className="block text-gray-700 text-sm font-bold mb-2">Spieltyp:</label>
                <select
                  value={gameType}
                  onChange={e => setGameType(e.target.value)}
                  className="w-full"
                  aria-label="Spieltyp auswählen"
                >
                  <option value="normal">Normalspiel</option>
                  <optgroup label="Pflichtsolo">
                    <option value="pflichtsolo_knochenloser">Knochenloser</option>
                    <option value="pflichtsolo_bilder">Bilder</option>
                    <option value="pflichtsolo_farbe">Farbe</option>
                  </optgroup>
                  <optgroup label="Lüstling">
                    <option value="lustling_knochenloser">Knochenloser</option>
                    <option value="lustling_bilder">Bilder</option>
                    <option value="lustling_farbe">Farbe</option>
                  </optgroup>
                  <option value="schlanker_martin">Schlanker Martin</option>
                  <option value="stilles_solo">Stilles Solo</option>
                  <option value="rote_luise">Rote Luise</option>
                </select>
              </div>
              <div>
                <label className="block text-gray-700 text-sm font-bold mb-2">Gewinner (Mehrfachauswahl):</label>
                <select
                  multiple
                  value={winningPlayers}
                  onChange={e => setWinningPlayers(Array.from(e.target.selectedOptions).map(o => o.value))}
                  className="w-full"
                  aria-label="Gewinner auswählen"
                >
                  {players.map(player => (
                    <option key={player} value={player}>{player}</option>
                  ))}
                </select>
              </div>
              <div className="col-span-full"> {/* Full width for this input */}
                <label className="block text-gray-700 text-sm font-bold mb-2">Punkte der Gewinner:</label>
                <input
                  type="number"
                  value={points}
                  onChange={e => setPoints(Number(e.target.value))}
                  min="0"
                  className="border p-2 rounded"
                  aria-label="Punkte der Gewinner"
                />
              </div>
            </div>
            {gameType === 'schlanker_martin' && (
              <div className="mb-4">
                <label className="inline-flex items-center">
                  <input
                    type="checkbox"
                    checked={noStichMade}
                    onChange={() => setNoStichMade(!noStichMade)}
                    className="form-checkbox h-5 w-5 text-red-600 rounded"
                  />
                  <span className="ml-2 text-gray-700">Kein Stich gemacht (Schlanker Martin)</span>
                </label>
              </div>
            )}
            <div className="mb-4">
              <label className="block text-gray-700 text-sm font-bold mb-2">Ansagen:</label>
              <div className="grid grid-cols-2 sm:grid-cols-4 gap-2"> {/* 4 columns */}
                {[
                  { key: 'Re', label: 'Re' },
                  { key: 'Kontra', label: 'Kontra' },
                  { key: 'GegenDieAlten', label: 'Gegen die Alten' },
                  { key: 'ReKontra', label: '(Re/Kontra)' },
                ].map(({ key, label }) => (
                  <label key={key} className={`inline-flex items-center ${gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p)).length === 1 && !['Keine90', 'Keine60', 'Keine30', 'Keine0'].includes(key) ? 'opacity-50' : ''}`}>
                    <input
                      type="checkbox"
                      checked={ansagen[key]}
                      onChange={() => setAnsagen(prev => ({ ...prev, [key]: !prev[key] }))}
                      disabled={gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p)).length === 1 && !['Keine90', 'Keine60', 'Keine30', 'Keine0'].includes(key)}
                      className="form-checkbox h-5 w-5 text-blue-600 rounded"
                    />
                    <span className="ml-2 text-gray-700">{label}</span>
                  </label>
                ))}
              </div>
              <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 mt-2"> {/* New row for KeineX */}
                {[
                  { key: 'Keine90', label: 'Keine 90' },
                  { key: 'Keine60', label: 'Keine 60' },
                  { key: 'Keine30', label: 'Keine 30' },
                  { key: 'Keine0', label: 'Keine 0' },
                ].map(({ key, label }) => (
                  <label key={key} className={`inline-flex items-center ${gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p)).length === 1 && !['Keine90', 'Keine60', 'Keine30', 'Keine0'].includes(key) ? 'opacity-50' : ''}`}>
                    <input
                      type="checkbox"
                      checked={ansagen[key]}
                      onChange={() => setAnsagen(prev => ({ ...prev, [key]: !prev[key] }))}
                      disabled={gameType === 'rote_luise' && players.filter(p => !winningPlayers.includes(p)).length === 1 && !['Keine90', 'Keine60', 'Keine30', 'Keine0'].includes(key)}
                      className="form-checkbox h-5 w-5 text-blue-600 rounded"
                    />
                    <span className="ml-2 text-gray-700">{label}</span>
                  </label>
                ))}
              </div>
            </div>
            <div className="mb-4">
              <label className="block text-gray-700 text-sm font-bold mb-2">Sonderpunkte:</label>
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4"> {/* 4 columns on large screens */}
                {[
                  { key: 'FuchsGefangenWinner', label: 'Fuchs gefangen (Gewinner)', type: 'number' },
                  { key: 'FuchsGefangenLoser', label: 'Fuchs gefangen (Verlierer)', type: 'number' },
                  { key: 'KarlchenMuellerWinner', label: 'Karlchen Müller (Gewinner)', type: 'number' },
                  { key: 'KarlchenMuellerLoser', label: 'Karlchen Müller (Verlierer)', type: 'number' },
                ].map(({ key, label, type }) => (
                  <div key={key} className="flex items-center justify-between">
                    <span className="text-gray-700 text-sm mr-2 flex-grow">{label}</span>
                    <input
                      type="number"
                      value={sonderpunkte[key]}
                      onChange={e => setSonderpunkte(prev => ({ ...prev, [key]: Math.max(0, Number(e.target.value)) }))}
                      min="0"
                      className="border p-2 rounded narrow"
                      aria-label={label}
                    />
                  </div>
                ))}
              </div>
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mt-2"> {/* New row for other sonderpunkte */}
                {[
                  { key: 'DoppelkopfWinner', label: 'Doppelkopf (Gewinner)', type: 'number' },
                  { key: 'DoppelkopfLoser', label: 'Doppelkopf (Verlierer)', type: 'number' },
                  { key: 'FuchsMachtLetztenStichWinner', label: 'Fuchs macht letzten Stich (Gewinner)', type: 'number' },
                  { key: 'FuchsMachtLetztenStichLoser', label: 'Fuchs macht letzten Stich (Verlierer)', type: 'number' },
                ].map(({ key, label, type }) => (
                  <div key={key} className="flex items-center justify-between">
                    <span className="text-gray-700 text-sm mr-2 flex-grow">{label}</span>
                    <input
                      type="number"
                      value={sonderpunkte[key]}
                      onChange={e => setSonderpunkte(prev => ({ ...prev, [key]: Math.max(0, Number(e.target.value)) }))}
                      min="0"
                      className="border p-2 rounded narrow"
                      aria-label={label}
                    />
                  </div>
                ))}
              </div>
              <div className="mt-4">
                <label className={`inline-flex items-center ${gameType !== 'schlanker_martin' ? 'opacity-50' : ''}`}>
                  <input
                    type="checkbox"
                    checked={sonderpunkte.SchlankerMartinSonderpunkt}
                    onChange={() => setSonderpunkte(prev => ({ ...prev, SchlankerMartinSonderpunkt: !prev.SchlankerMartinSonderpunkt }))}
                    disabled={gameType !== 'schlanker_martin'}
                    className="form-checkbox h-5 w-5 text-purple-600 rounded"
                  />
                  <span className="ml-2 text-gray-700">Schlanker Martin Sonderpunkt</span>
                </label>
              </div>
            </div>
            <button className="btn btn-secondary w-full text-lg" onClick={addGame} aria-label="Spiel protokollieren"> {/* Added text-lg class */}
              {editingGameIndex !== null ? 'Änderungen speichern' : 'Protokollieren'}
            </button>
          </div>

          {/* Game History */}
          <div className="card">
            <h2 className="text-xl font-semibold text-gray-700 mb-3">Spielverlauf</h2>
            <div className="overflow-x-auto">
              <table className="game-history-table w-full text-left table-auto">
                <thead>
                  <tr className="bg-gray-200 text-gray-700">
                    <th className="p-2 whitespace-nowrap rounded-tl-lg">Spiel</th>
                    <th className="p-2 whitespace-nowrap text-darkblue-bold">Punkte</th> {/* Changed from Pot to Punkte */}
                    <th className="p-2 details-cell">Details</th> {/* Added details-cell class */}
                    {players.map(player => (
                      <th key={player} className="p-2 whitespace-nowrap">
                        <div className={`player-header-content ${playerSoloStatus[player]?.knochenloser && playerSoloStatus[player]?.bilder && playerSoloStatus[player]?.farbe ? 'player-header-completed-solos' : ''}`}>
                          <span className="font-bold">{player}</span> {/* Added font-bold */}
                          <div className="solo-indicators">
                            <span className={`solo-indicator ${playerSoloStatus[player]?.knochenloser ? 'completed' : 'pending'}`} title="Knochenloser Solo">K</span>
                            <span className={`solo-indicator ${playerSoloStatus[player]?.bilder ? 'completed' : 'pending'}`} title="Bilder Solo">B</span>
                            <span className={`solo-indicator ${playerSoloStatus[player]?.farbe ? 'completed' : 'pending'}`} title="Farbe Solo">F</span>
                          </div>
                        </div>
                      </th>
                    ))}
                    <th className="p-2 whitespace-nowrap rounded-tr-lg text-darkblue-bold">Pot</th>
                    <th className="p-2 whitespace-nowrap">Aktion</th>
                  </tr>
                </thead>
                <tbody>
                  {gameHistory.length === 0 ? (
                    <tr>
                      <td colSpan={players.length + 5} className="text-gray-500 text-center py-4">Noch keine Spiele protokolliert.</td>
                    </tr>
                  ) : (
                    gameHistory.map((game, index) => (
                      <tr key={index} className="hover:bg-gray-50">
                        <td className="p-2 whitespace-nowrap">
                          {game.gameType === 'rote_luise' ? `Rote Luise (${game.points})` :
                           game.gameType.includes('_') ? 
                            `${game.gameType.split('_')[0].charAt(0).toUpperCase() + game.gameType.split('_')[0].slice(1)} (${game.points})<br>(${game.gameType.split('_')[1].charAt(0).toUpperCase() + game.gameType.split('_')[1].slice(1)})` : 
                            `${game.gameType.charAt(0).toUpperCase() + game.gameType.slice(1)} (${game.points})`}
                        </td>
                        <td className="p-2 whitespace-nowrap text-darkblue-bold">{game.potChange}</td>
                        <td className="p-2 details-cell"> {/* Apply details-cell class here */}
                          {[...game.ansagen, ...game.sonderpunkte.map(sp => {
                            const [key, value] = sp.split(':');
                            // Map sonderpunkte keys back to readable labels
                            const spLabels = {
                                DoppelkopfWinner: 'Doppelkopf (Gewinner)',
                                DoppelkopfLoser: 'Doppelkopf (Verlierer)',
                                KarlchenMuellerWinner: 'Karlchen Müller (Gewinner)',
                                KarlchenMuellerLoser: 'Karlchen Müller (Verlierer)',
                                FuchsGefangenWinner: 'Fuchs gefangen (Gewinner)',
                                FuchsGefangenLoser: 'Fuchs gefangen (Verlierer)',
                                FuchsMachtLetztenStichWinner: 'Fuchs macht letzten Stich (Gewinner)',
                                FuchsMachtLetztenStichLoser: 'Fuchs macht letzten Stich (Verlierer)',
                                SchlankerMartinSonderpunkt: 'Schlanker Martin Sonderpunkt',
                            };
                            return `${spLabels[key] || key}: ${value}`;
                          })].join('; ') || '-'}
                        </td>
                        {players.map(player => (
                          <td key={player} className={`p-2 ${game.playerScores[player] < 0 ? 'points-negative' : 'points-positive'}`}>
                            {game.playerScores[player] || 0}
                          </td>
                        ))}
                        <td className="p-2 whitespace-nowrap text-darkblue-bold">{game.potAfterGame}</td>
                        <td className="p-2 whitespace-nowrap">
                          <button className="btn btn-warning text-sm px-3 py-1" onClick={() => editGame(index)} aria-label={`Spiel ${index + 1} bearbeiten`}> {/* Changed to btn-warning */}
                            Ändern
                          </button>
                          <button className="btn btn-danger text-sm px-3 py-1 ml-2" onClick={() => deleteGame(index)} aria-label={`Spiel ${index + 1} löschen`}>
                            Löschen
                          </button>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
                <tfoot>
                  <tr className="bg-gray-200 font-bold text-gray-800 border-t-2 border-gray-400">
                    <td className="p-2" colSpan="3">Gesamtstand</td>
                    {players.map(player => {
                      const total = gameHistory.reduce((sum, game) => sum + (game.playerScores[player] || 0), -30);
                      return (
                        <td key={player} className={`p-2 ${total < 0 ? 'points-negative' : 'points-positive'}`}>
                          {total}
                        </td>
                      );
                    })}
                    <td colSpan="2"></td>
                  </tr>
                  <tr className="bg-gray-200 font-bold text-gray-800 ranking-row">
                    <td className="p-2" colSpan="3">Ranking</td>
                    {players.map(player => {
                      const total = gameHistory.reduce((sum, game) => sum + (game.playerScores[player] || 0), -30);
                      const rank = players.map(p => ({
                        name: p,
                        score: gameHistory.reduce((sum, game) => sum + (game.playerScores[p] || 0), -30)
                      })).sort((a, b) => b.score - a.score).findIndex(p => p.name === player) + 1;
                      return <td key={player} className="p-2">{`${rank}.`}</td>;
                    })}
                    <td colSpan="2"></td>
                  </tr>
                </tfoot>
              </table>
            </div>
            <div className="flex gap-3 mt-4">
              <button className="btn btn-secondary" onClick={undo} disabled={historyPointer === 0} aria-label="Letzte Aktion rückgängig machen">
                Rückgängig
              </button>
              <button className="btn btn-secondary" onClick={redo} disabled={historyPointer === historyStates.length - 1} aria-label="Letzte Aktion wiederholen">
                Wiederholen
              </button>
            </div>
          </div>

          {/* Session Management */}
          <div className="card">
            <h2 className="text-xl font-semibold text-gray-700 mb-3">Sitzung verwalten</h2>
            <div className="flex flex-col sm:flex-row gap-3">
              <button
                className="btn btn-danger flex-grow"
                onClick={() => {
                  setModalMessage("Möchtest du wirklich eine neue Sitzung starten? Alle ungespeicherten Daten gehen verloren.");
                  setModalCallback(() => () => startNewSession(dbInstance, true));
                  setShowModal(true);
                }}
                aria-label="Neue Sitzung starten"
              >
                Neue Sitzung starten
              </button>
              <button className="btn btn-primary flex-grow" onClick={() => saveCurrentSession(dbInstance, true)} aria-label="Sitzung speichern">
                Sitzung speichern
              </button>
              <button className="btn btn-secondary flex-grow" onClick={() => loadAllSessions(dbInstance, userId)} aria-label="Sitzungen laden">
                Sitzungen laden
              </button>
            </div>
            <div className="mt-4 space-y-2">
              {sessions.map(session => (
                <div key={session.id} className="bg-gray-100 p-3 rounded-lg flex justify-between items-center shadow-sm">
                  <span className="font-semibold text-gray-700">{session.id}</span>
                  <div className="flex gap-2">
                    <button
                      className="btn btn-secondary text-sm px-3 py-1"
                      onClick={() => {
                          setCurrentSessionId(session.id);
                          applyState({
                              players: session.players || defaultPlayers,
                              pot: session.pot || 120,
                              gameHistory: session.history || [],
                              playerSoloStatus: session.playerSoloStatus || defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
                          });
                          setHistoryStates([{
                              players: session.players || defaultPlayers,
                              pot: session.pot || 120,
                              gameHistory: session.history || [],
                              playerSoloStatus: session.playerSoloStatus || defaultPlayers.reduce((acc, p) => ({ ...acc, [p]: { ...initialPlayerSoloStatus } }), {})
                          }]);
                          setHistoryPointer(0);
                      }}
                      aria-label={`Sitzung ${session.id} laden`}
                    >
                      Laden
                    </button>
                    <button
                      className="btn btn-danger text-sm px-3 py-1"
                      onClick={() => {
                        setModalMessage(`Möchtest du die Sitzung "${session.id}" wirklich löschen?`);
                        setModalCallback(() => async () => deleteSession(session.id));
                        setShowModal(true);
                      }}
                      aria-label={`Sitzung ${session.id} löschen`}
                    >
                      Löschen
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Message Modal */}
          {showModal && (
            <div className="modal" style={{ display: 'flex' }}>
              <div className="modal-content">
                <span className="close-button" onClick={() => setShowModal(false)} aria-label="Modal schließen">×</span>
                <p className="text-lg text-gray-800">{modalMessage}</p>
                {modalCallback && (
                  <div className="modal-buttons">
                    <button className="btn btn-secondary px-4 py-2" onClick={() => { setShowModal(false); setModalCallback(null); }} aria-label="Abbrechen">
                      Abbrechen
                    </button>
                    <button className="btn btn-danger px-4 py-2" onClick={() => { modalCallback(); setShowModal(false); setModalCallback(null); }} aria-label="Bestätigen">
                      Bestätigen
                    </button>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Replace Player Modal */}
          {showReplaceModal && (
            <div className="modal" style={{ display: 'flex' }}>
              <div className="modal-content">
                <span className="close-button" onClick={() => setShowReplaceModal(false)} aria-label="Modal schließen">×</span>
                <h3 className="text-xl font-semibold text-gray-700 mb-4">Spieler ersetzen</h3>
                <p className="text-gray-700 mb-4">Wähle einen Spieler zum Ersetzen aus:</p>
                <div className="mb-4">
                  <label className="block text-gray-700 text-sm font-bold mb-2">Spieler zum Ersetzen:</label>
                  <select
                    value={playerToReplace}
                    onChange={e => setPlayerToReplace(e.target.value)}
                    className="w-full"
                    aria-label="Spieler zum Ersetzen auswählen"
                  >
                    <option value="">Wähle einen Spieler</option>
                    {players.map(player => (
                      <option key={player} value={player}>{player}</option>
                    ))}
                  </select>
                </div>
                <div className="mb-6">
                  <label className="block text-gray-700 text-sm font-bold mb-2">Neuer Spielername:</label>
                  <input
                    type="text"
                    value={newPlayerName}
                    onChange={e => setNewPlayerName(e.target.value)}
                    placeholder="Neuer Spielername"
                    className="border p-2 rounded"
                    aria-label="Neuer Spielername"
                  />
                </div>
                <div className="modal-buttons">
                  <button className="btn btn-secondary px-4 py-2" onClick={() => setShowReplaceModal(false)} aria-label="Abbrechen">
                    Abbrechen
                  </button>
                  <button className="btn btn-primary px-4 py-2" onClick={replacePlayer} aria-label="Ersetzen">
                    Ersetzen
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    };

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
